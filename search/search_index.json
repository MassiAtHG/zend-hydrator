{
    "docs": [
        {
            "location": "/",
            "text": "zend-hydrator\n\n\n\n\n\n\nZend\\Hydrator\n provides utilities for mapping arrays to objects, and vice\nversa, including facilities for filtering which data is mapped as well as\nproviding mechanisms for mapping nested structures.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-hydrator/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-hydrator/",
            "title": "Home"
        },
        {
            "location": "/#zend-hydrator",
            "text": "Zend\\Hydrator  provides utilities for mapping arrays to objects, and vice\nversa, including facilities for filtering which data is mapped as well as\nproviding mechanisms for mapping nested structures.   File issues at https://github.com/zendframework/zend-hydrator/issues  Documentation is at https://docs.zendframework.com/zend-hydrator/",
            "title": "zend-hydrator"
        },
        {
            "location": "/v3/quick-start/",
            "text": "zend-hydrator\n\n\nHydration is the act of populating an object from a set of data.\n\n\nzend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.\n\n\nThe component consists of interfaces, and several implementations for common use cases.\n\n\nBase Interfaces\n\n\nExtractionInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /**\n     * Extract values from an object\n     *\n     * @return mixed[]\n     */\n    public function extract(object $object) : array;\n}\n\n\n\nHydrationInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /**\n     * Hydrate $object with the provided $data.\n     *\n     * @param mixed[] $data\n     * @return object The implementation should return an object of any type.\n     *     By purposely omitting the return type from the signature,\n     *     implementations may choose to specify a more specific type.\n     */\n    public function hydrate(array $data, object $object);\n}\n\n\n\nHydratorInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}\n\n\n\nUsage\n\n\nUsage involves instantiating the hydrator, and then passing information to it.\n\n\nuse Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializableHydrator();\n\n// To hydrate an object from values in an array:\n$object = $hydrator->hydrate($data, new ArrayObject());\n\n// or, going the other way and extracting the values from an object as an array:\n$data = $hydrator->extract($object);\n\n\n\nAvailable Implementations\n\n\nZend\\Hydrator\\ArraySerializableHydrator\n\n\nFollows the definition of \nArrayObject\n. Objects must implement either the \nexchangeArray()\n or\n\npopulate()\n methods to support hydration, and the \ngetArrayCopy()\n method to support extraction.\n\n\nZend\\Hydrator\\ClassMethodsHydrator\n\n\nAny data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction, according to the following rules:\n\n\n\n\nis*()\n, \nhas*()\n, and \nget*()\n methods will be extracted, and the method\n  prefix will be removed from the property name.\n\n\nset*()\n methods will be used when hydrating properties.\n\n\n\n\nZend\\Hydrator\\DelegatingHydrator\n\n\nComposes a hydrator locator, and will delegate \nhydrate()\n and \nextract()\n calls\nto the appropriate one based upon the class name of the object being operated\non.\n\n\n// Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethodsHydrator();\n$artistHydrator = new Zend\\Hydrator\\ClassMethodsHydrator();\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object\n$array  = $delegating->extract(new Artist());\n$artist = $delegating->hydrate($data, new Artist());\n\n\n\nZend\\Hydrator\\ObjectPropertyHydrator\n\n\nAny data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.\n\n\nZend\\Hydrator\\ReflectionHydrator\n\n\nSimilar to the \nObjectPropertyHydrator\n, but uses \nPHP's reflection API\n\nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Quick Start"
        },
        {
            "location": "/v3/quick-start/#zend-hydrator",
            "text": "Hydration is the act of populating an object from a set of data.  zend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.  The component consists of interfaces, and several implementations for common use cases.",
            "title": "zend-hydrator"
        },
        {
            "location": "/v3/quick-start/#base-interfaces",
            "text": "",
            "title": "Base Interfaces"
        },
        {
            "location": "/v3/quick-start/#extractioninterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /**\n     * Extract values from an object\n     *\n     * @return mixed[]\n     */\n    public function extract(object $object) : array;\n}",
            "title": "ExtractionInterface"
        },
        {
            "location": "/v3/quick-start/#hydrationinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /**\n     * Hydrate $object with the provided $data.\n     *\n     * @param mixed[] $data\n     * @return object The implementation should return an object of any type.\n     *     By purposely omitting the return type from the signature,\n     *     implementations may choose to specify a more specific type.\n     */\n    public function hydrate(array $data, object $object);\n}",
            "title": "HydrationInterface"
        },
        {
            "location": "/v3/quick-start/#hydratorinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}",
            "title": "HydratorInterface"
        },
        {
            "location": "/v3/quick-start/#usage",
            "text": "Usage involves instantiating the hydrator, and then passing information to it.  use Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializableHydrator();\n\n// To hydrate an object from values in an array:\n$object = $hydrator->hydrate($data, new ArrayObject());\n\n// or, going the other way and extracting the values from an object as an array:\n$data = $hydrator->extract($object);",
            "title": "Usage"
        },
        {
            "location": "/v3/quick-start/#available-implementations",
            "text": "",
            "title": "Available Implementations"
        },
        {
            "location": "/v3/quick-start/#zend92hydrator92arrayserializablehydrator",
            "text": "Follows the definition of  ArrayObject . Objects must implement either the  exchangeArray()  or populate()  methods to support hydration, and the  getArrayCopy()  method to support extraction.",
            "title": "Zend\\Hydrator\\ArraySerializableHydrator"
        },
        {
            "location": "/v3/quick-start/#zend92hydrator92classmethodshydrator",
            "text": "Any data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction, according to the following rules:   is*() ,  has*() , and  get*()  methods will be extracted, and the method\n  prefix will be removed from the property name.  set*()  methods will be used when hydrating properties.",
            "title": "Zend\\Hydrator\\ClassMethodsHydrator"
        },
        {
            "location": "/v3/quick-start/#zend92hydrator92delegatinghydrator",
            "text": "Composes a hydrator locator, and will delegate  hydrate()  and  extract()  calls\nto the appropriate one based upon the class name of the object being operated\non.  // Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethodsHydrator();\n$artistHydrator = new Zend\\Hydrator\\ClassMethodsHydrator();\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object\n$array  = $delegating->extract(new Artist());\n$artist = $delegating->hydrate($data, new Artist());",
            "title": "Zend\\Hydrator\\DelegatingHydrator"
        },
        {
            "location": "/v3/quick-start/#zend92hydrator92objectpropertyhydrator",
            "text": "Any data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.",
            "title": "Zend\\Hydrator\\ObjectPropertyHydrator"
        },
        {
            "location": "/v3/quick-start/#zend92hydrator92reflectionhydrator",
            "text": "Similar to the  ObjectPropertyHydrator , but uses  PHP's reflection API \nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Zend\\Hydrator\\ReflectionHydrator"
        },
        {
            "location": "/v3/filter/",
            "text": "Zend\\Hydrator\\Filter\n\n\nHydrator filters allow you to manipulate the behavior of the \nextract()\n\noperation.  This is especially useful, if you want to omit some internals (e.g.\n\ngetServiceManager()\n) from the array representation.\n\n\nIt comes with a helpful \nComposite\n implementation, and several filters for\ncommon use cases. The filters are composed in the \nAbstractHydrator\n, so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter does not match.\n     */\n    public function filter(string $property) : bool;\n}\n\n\n\nIf it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.\n\n\nFilter implementations\n\n\nZend\\Hydrator\\Filter\\GetFilter\n\n\nThis filter is used in the \nClassMethodsHydrator\n to decide which getters will\nbe extracted. It checks if the key to extract starts with \nget\n or the object\ncontains a method beginning with \nget\n (e.g., \nZend\\Foo\\Bar::getFoo\n).\n\n\nZend\\Hydrator\\Filter\\HasFilter\n\n\nThis filter is used in the \nClassMethodsHydrator\n to decide which \nhas\n methods\nwill be extracted. It checks if the key to extract begins with \nhas\n or the\nobject contains a method beginning with \nhas\n (e.g., \nZend\\Foo\\Bar::hasFoo\n).\n\n\nZend\\Hydrator\\Filter\\IsFilter\n\n\nThis filter is used in the \nClassMethodsHydrator\n to decide which \nis\n methods\nwill be extracted. It checks if the key to extract begins with \nis\n or the\nobject contains a method beginning with \nis\n (e.g., \nZend\\Foo\\Bar::isFoo\n).\n\n\nZend\\Hydrator\\Filter\\MethodMatchFilter\n\n\nThis filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass \nfalse\n to change\nthe behavior.\n\n\nZend\\Hydrator\\Filter\\NumberOfParameterFilter\n\n\nThis filter is used in the \nClassMethodsHydrator\n to check the number of\nparameters. By convention, the \nget\n, \nhas\n and \nis\n methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.\n\n\nUse FilterComposite for complex filters\n\n\nFilterComposite\n implements \nFilterInterface\n as well, so you can add it as a\nregular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent filters with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR\n\n\nAt the given level of the composite, at least one filter set using\n\nCONDITION_OR\n must return true to extract the value.\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND\n\n\nAt the given level of the composite, \nall\n filters set using \nCONDITION_AND\n\nmust return true to extract the value.\n\n\nFilterComposite Examples\n\n\nTo illustrate how conditions apply when composing filters, consider the\nfollowing set of filters:\n\n\n$composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);\n\n\n\nThe above is roughly equivalent to the following conditional:\n\n\n// This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    // do extraction\n}\n\n\n\nIf you only have one condition block (e.g., only \nAND\n or \nOR\n filters), the\nother condition type will be completely ignored.\n\n\nA bit more complex filter can look like this:\n\n\n$composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the ClassMethodsHydrator:\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}\n\n\n\nIf you perform this on the \nClassMethodsHydrator\n, all getters will get\nextracted, except for \ngetServiceManager()\n and \ngetEventManager()\n.\n\n\nUsing the provider interface\n\n\nZend\\Hydrator\\Filter\\FilterProviderInterface\n allows you to configure the\nbehavior of the hydrator inside your objects.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}\n\n\n\n(The \ngetFilter()\n method is automatically excluded from \nextract()\n.) If the\nextracted object implements the \nZend\\Hydrator\\Filter\\FilterProviderInterface\n,\nthe returned \nFilterInterface\n instance can also be a \nFilterComposite\n.\n\n\nFor example:\n\n\nClass Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethodsHydrator(false);\n$extractedArray = $hydrator->extract(new Foo());\n\n\n\n$extractedArray\n will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.\n\n\n\n\nNote\n\n\nAll pre-registered filters from the \nClassMethodsHydrator\n hydrator are ignored when\nthis interface is used. More on those methods below.\n\n\n\n\nFilter-enabled hydrators and the composite filter\n\n\nHydrators can indicate they are filter-enabled by implementing\n\nZend\\Hydrator\\Filter\\FilterEnabledInterface\n:\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterEnabledInterface extends FilterProviderInterface\n{\n    /**\n     * Add a new filter to take care of what needs to be hydrated.\n     * To exclude e.g. the method getServiceLocator:\n     *\n     * <code>\n     * $composite->addFilter(\n     *     \"servicelocator\",\n     *     function ($property) {\n     *         [$class, $method] = explode('::', $property, 2);\n     *         return $method !== 'getServiceLocator';\n     *     },\n     *     FilterComposite::CONDITION_AND\n     * );\n     * </code>\n     *\n     * @param string $name Index in the composite\n     * @param callable|FilterInterface $filter\n     */\n    public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void;\n\n    /**\n     * Check whether a specific filter exists at key $name or not\n     *\n     * @param string $name Index in the composite\n     */\n    public function hasFilter(string $name) : bool;\n\n    /**\n     * Remove a filter from the composition.\n     *\n     * To not extract \"has\" methods, you simply need to unregister it\n     *\n     * <code>\n     * $filterComposite->removeFilter('has');\n     * </code>\n     */\n    public function removeFilter(string $name) : void;\n}\n\n\n\n\n\nNote that the interface extends \nFilterProviderInterface\n, which means it also\nincludes the \ngetFilter()\n method.\n\n\n\n\nThe \nFilterEnabledInterface\n makes the assumption that the class will be backed\nby a \nZend\\Hydrator\\Filter\\FilterComposite\n; the various \naddFilter()\n,\n\nhasFilter()\n, and \nremoveFilter()\n methods are expected to proxy to a\n\nFilterComposite\n instance.\n\n\nAbstractHydrator\n, on which all the hydrators shipped in this package are\nbuilt, implements \nFilterEnabledInterface\n. Of the hydrators shipped, only one,\n\nClassMethodsHydrator\n, defines any filters from the outset. Its constructor\nincludes the following:\n\n\n$this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);\n\n\n\nRemove filters\n\n\nIf you want to tell a filter-enabled hydrator such as \nClassMethodsHydrator\n not\nto extract methods that start with \nis\n, remove the related filter:\n\n\n$hydrator = new ClassMethodsHydrator(false);\n$hydrator->removeFilter('is');\n\n\n\nAfter performing the above, the key/value pairs for \nis\n methods will no longer\nend up in your extracted array.\n\n\nAdd filters\n\n\nYou can add filters using the \naddFilter()\n method. Filters can either implement\n\nFilterInterface\n, or simply be PHP callables:\n\n\n$hydrator->addFilter('len', function($property) {\n    return strlen($property) === 3;\n});\n\n\n\nBy default, every filter you add will be added with a conditional \nOR\n. If you\nwant to add it with \nAND\n (such as the \nClassMethodsHydrator\n does with its\ncomposed \nNumberOfParameterFilter\n, demonstrated above) provide the conditon as\nthe third argument to \naddFilter\n:\n\n\n$hydrator->addFilter('len', function($property) {\n    return strlen($property) === 3;\n}, FilterComposite::CONDITION_AND);\n\n\n\nOne common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:\n\n\n$hydrator->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n\n\n\nThe example above will exclude the \ngetServiceManager()\n method and the\n\nservicemanager\n key from extraction, even if the \nget\n filter wants to add it.",
            "title": "Filters"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter",
            "text": "Hydrator filters allow you to manipulate the behavior of the  extract() \noperation.  This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation.  It comes with a helpful  Composite  implementation, and several filters for\ncommon use cases. The filters are composed in the  AbstractHydrator , so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter does not match.\n     */\n    public function filter(string $property) : bool;\n}  If it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.",
            "title": "Zend\\Hydrator\\Filter"
        },
        {
            "location": "/v3/filter/#filter-implementations",
            "text": "",
            "title": "Filter implementations"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92getfilter",
            "text": "This filter is used in the  ClassMethodsHydrator  to decide which getters will\nbe extracted. It checks if the key to extract starts with  get  or the object\ncontains a method beginning with  get  (e.g.,  Zend\\Foo\\Bar::getFoo ).",
            "title": "Zend\\Hydrator\\Filter\\GetFilter"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92hasfilter",
            "text": "This filter is used in the  ClassMethodsHydrator  to decide which  has  methods\nwill be extracted. It checks if the key to extract begins with  has  or the\nobject contains a method beginning with  has  (e.g.,  Zend\\Foo\\Bar::hasFoo ).",
            "title": "Zend\\Hydrator\\Filter\\HasFilter"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92isfilter",
            "text": "This filter is used in the  ClassMethodsHydrator  to decide which  is  methods\nwill be extracted. It checks if the key to extract begins with  is  or the\nobject contains a method beginning with  is  (e.g.,  Zend\\Foo\\Bar::isFoo ).",
            "title": "Zend\\Hydrator\\Filter\\IsFilter"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92methodmatchfilter",
            "text": "This filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass  false  to change\nthe behavior.",
            "title": "Zend\\Hydrator\\Filter\\MethodMatchFilter"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92numberofparameterfilter",
            "text": "This filter is used in the  ClassMethodsHydrator  to check the number of\nparameters. By convention, the  get ,  has  and  is  methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.",
            "title": "Zend\\Hydrator\\Filter\\NumberOfParameterFilter"
        },
        {
            "location": "/v3/filter/#use-filtercomposite-for-complex-filters",
            "text": "FilterComposite  implements  FilterInterface  as well, so you can add it as a\nregular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent filters with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:",
            "title": "Use FilterComposite for complex filters"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92filtercompositecondition95or",
            "text": "At the given level of the composite, at least one filter set using CONDITION_OR  must return true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR"
        },
        {
            "location": "/v3/filter/#zend92hydrator92filter92filtercompositecondition95and",
            "text": "At the given level of the composite,  all  filters set using  CONDITION_AND \nmust return true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND"
        },
        {
            "location": "/v3/filter/#filtercomposite-examples",
            "text": "To illustrate how conditions apply when composing filters, consider the\nfollowing set of filters:  $composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);  The above is roughly equivalent to the following conditional:  // This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    // do extraction\n}  If you only have one condition block (e.g., only  AND  or  OR  filters), the\nother condition type will be completely ignored.  A bit more complex filter can look like this:  $composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the ClassMethodsHydrator:\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}  If you perform this on the  ClassMethodsHydrator , all getters will get\nextracted, except for  getServiceManager()  and  getEventManager() .",
            "title": "FilterComposite Examples"
        },
        {
            "location": "/v3/filter/#using-the-provider-interface",
            "text": "Zend\\Hydrator\\Filter\\FilterProviderInterface  allows you to configure the\nbehavior of the hydrator inside your objects.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}  (The  getFilter()  method is automatically excluded from  extract() .) If the\nextracted object implements the  Zend\\Hydrator\\Filter\\FilterProviderInterface ,\nthe returned  FilterInterface  instance can also be a  FilterComposite .  For example:  Class Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethodsHydrator(false);\n$extractedArray = $hydrator->extract(new Foo());  $extractedArray  will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.",
            "title": "Using the provider interface"
        },
        {
            "location": "/v3/filter/#note",
            "text": "All pre-registered filters from the  ClassMethodsHydrator  hydrator are ignored when\nthis interface is used. More on those methods below.",
            "title": "Note"
        },
        {
            "location": "/v3/filter/#filter-enabled-hydrators-and-the-composite-filter",
            "text": "Hydrators can indicate they are filter-enabled by implementing Zend\\Hydrator\\Filter\\FilterEnabledInterface :  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterEnabledInterface extends FilterProviderInterface\n{\n    /**\n     * Add a new filter to take care of what needs to be hydrated.\n     * To exclude e.g. the method getServiceLocator:\n     *\n     * <code>\n     * $composite->addFilter(\n     *     \"servicelocator\",\n     *     function ($property) {\n     *         [$class, $method] = explode('::', $property, 2);\n     *         return $method !== 'getServiceLocator';\n     *     },\n     *     FilterComposite::CONDITION_AND\n     * );\n     * </code>\n     *\n     * @param string $name Index in the composite\n     * @param callable|FilterInterface $filter\n     */\n    public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void;\n\n    /**\n     * Check whether a specific filter exists at key $name or not\n     *\n     * @param string $name Index in the composite\n     */\n    public function hasFilter(string $name) : bool;\n\n    /**\n     * Remove a filter from the composition.\n     *\n     * To not extract \"has\" methods, you simply need to unregister it\n     *\n     * <code>\n     * $filterComposite->removeFilter('has');\n     * </code>\n     */\n    public function removeFilter(string $name) : void;\n}   Note that the interface extends  FilterProviderInterface , which means it also\nincludes the  getFilter()  method.   The  FilterEnabledInterface  makes the assumption that the class will be backed\nby a  Zend\\Hydrator\\Filter\\FilterComposite ; the various  addFilter() , hasFilter() , and  removeFilter()  methods are expected to proxy to a FilterComposite  instance.  AbstractHydrator , on which all the hydrators shipped in this package are\nbuilt, implements  FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor\nincludes the following:  $this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);",
            "title": "Filter-enabled hydrators and the composite filter"
        },
        {
            "location": "/v3/filter/#remove-filters",
            "text": "If you want to tell a filter-enabled hydrator such as  ClassMethodsHydrator  not\nto extract methods that start with  is , remove the related filter:  $hydrator = new ClassMethodsHydrator(false);\n$hydrator->removeFilter('is');  After performing the above, the key/value pairs for  is  methods will no longer\nend up in your extracted array.",
            "title": "Remove filters"
        },
        {
            "location": "/v3/filter/#add-filters",
            "text": "You can add filters using the  addFilter()  method. Filters can either implement FilterInterface , or simply be PHP callables:  $hydrator->addFilter('len', function($property) {\n    return strlen($property) === 3;\n});  By default, every filter you add will be added with a conditional  OR . If you\nwant to add it with  AND  (such as the  ClassMethodsHydrator  does with its\ncomposed  NumberOfParameterFilter , demonstrated above) provide the conditon as\nthe third argument to  addFilter :  $hydrator->addFilter('len', function($property) {\n    return strlen($property) === 3;\n}, FilterComposite::CONDITION_AND);  One common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:  $hydrator->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);  The example above will exclude the  getServiceManager()  method and the servicemanager  key from extraction, even if the  get  filter wants to add it.",
            "title": "Add filters"
        },
        {
            "location": "/v3/strategy/",
            "text": "Zend\\Hydrator\\Strategy\n\n\nYou can compose \nZend\\Hydrator\\Strategy\\StrategyInterface\n instances in any of\nthe hydrators to manipulate the way they behave on \nextract()\n and \nhydrate()\n\nfor specific key/value pairs. The interface offers the following definitions:\n\n\nnamespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n    /**\n     * Converts the given value so that it can be extracted by the hydrator.\n     *\n     * @param  mixed       $value The original value.\n     * @param  null|object $object (optional) The original object for context.\n     * @return mixed       Returns the value that should be extracted.\n     */\n    public function extract($value, ?object $object = null);\n\n    /**\n     * Converts the given value so that it can be hydrated by the hydrator.\n     *\n     * @param  mixed      $value The original value.\n     * @param  null|array $data (optional) The original data for context.\n     * @return mixed      Returns the value that should be hydrated.\n     */\n    public function hydrate($value, ?array $data = null);\n}\n\n\n\nThis interface is similar to what the \nZend\\Hydrator\\ExtractionInterface\n and\n\nZend\\Hydrator\\HydrationInterface\n provide; the reason is that strategies\nprovide a proxy implementation for \nhydrate()\n and \nextract()\n on individual\nvalues. For this reason, their return types are listed as mixed, versus as\n\narray\n and \nobject\n, respectively.\n\n\nAdding strategies to the hydrators\n\n\nThis package provides the interface \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n.\nHydrators can implement this interface, and then call on its \ngetStrategy()\n\nmethod in order to extract or hydrate individual values. The interface has the\nfollowing definition:\n\n\nnamespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     */\n    public function addStrategy(string $name, StrategyInterface $strategy) : void;\n\n    /**\n     * Gets the strategy with the given name.\n     */\n    public function getStrategy(string $name) : StrategyInterface;\n\n    /**\n     * Checks if the strategy with the given name exists.\n     */\n    public function hasStrategy(string $name) : bool;\n\n    /**\n     * Removes the strategy with the given name.\n     */\n    public function removeStrategy(string $name) : void;\n}\n\n\n\nWe provide a default implementation of the interface as part of\n\nZend\\Hydrator\\AbstractHydrator\n; it uses an array property to store and\nretrieve strategies by name when extracting and hydrating values. Since all\nshipped hydrators are based on \nAbstractHydrator\n, they share these\ncapabilities.\n\n\nAdditionally, the functionality that consumes strategies within\n\nAbstractHydrator\n also contains checks if a naming strategy is composed, and,\nif present, will use it to translate the property name prior to looking up a\n  strategy for it.\n\n\nAvailable implementations\n\n\nZend\\Hydrator\\Strategy\\BooleanStrategy\n\n\nThis strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for \ntrue\n and\n\nfalse\n.\n\n\nZend\\Hydrator\\Strategy\\ClosureStrategy\n\n\nThis is a strategy that allows you to pass in options for:\n\n\n\n\nhydrate\n, a callback to be called when hydrating a value, and\n\n\nextract\n, a callback to be called when extracting a value.\n\n\n\n\nZend\\Hydrator\\Strategy\\DateTimeFormatterStrategy\n\n\nDateTimeFormatterStrategy\n provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.\n\n\nThe strategy allows \nDateTime\n formats that use \n!\n to prepend the format, or\n\n|\n or \n+\n to append it; these ensure that, during hydration, the new \nDateTime\n\ninstance created will set the time element accordingly. As a specific example,\n\nY-m-d|\n will drop the time component, ensuring comparisons are based on a\nmidnight time value.\n\n\nStarting in version 3.0, the constructor defines a third, optional argument,\n\n$dateTimeFallback\n.  If enabled and hydration fails, the given string is parsed\nby the \nDateTime\n constructor, as demonstrated below:\n\n\n// Previous behavior:\n$strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP');\n$hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01'); // Format is the same; returns DateTime instance\n$hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01');        // Format is different; value is not hydrated\n\n// Using new $dateTimeFallback flag; both values are hydrated:\n$strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP', null, true);\n$hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01');\n$hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01');\n\n\n\nZend\\Hydrator\\Strategy\\DefaultStrategy\n\n\nThe \nDefaultStrategy\n simply proxies everything through, without performing any\nconversion of values.\n\n\nZend\\Hydrator\\Strategy\\ExplodeStrategy\n\n\nThis strategy is a wrapper around PHP's \nimplode()\n and \nexplode()\n functions.\nThe delimiter and a limit can be provided to the constructor; the limit will\nonly be used for \nextract\n operations.\n\n\nZend\\Hydrator\\Strategy\\SerializableStrategy\n\n\nSerializableStrategy\n provides the functionality backing\n\nZend\\Hydrator\\ArraySerializableHydrator\n. You can use it with custom\nimplementations for \nZend\\Serializer\\Adapter\\AdapterInterface\n if you want to as\nwell.\n\n\nZend\\Hydrator\\Strategy\\StrategyChain\n\n\nThis strategy takes an array of \nStrategyInterface\n instances and iterates\nover them when performing \nextract()\n and \nhydrate()\n operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.\n\n\nWriting custom strategies\n\n\nThe following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing \nstr_rot13()\n during both the \nextract()\n and \nhydrate()\n operations:\n\n\nclass Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}\n\n\n\nThis is the example class with which we want to use the hydrator example:\n\n\nclass Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}\n\n\n\nNow, we'll add the \nrot13\n strategy to the method \ngetFoo()\n and \nsetFoo($foo)\n:\n\n\n$foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethodsHydrator();\n$hydrator->addStrategy('foo', new Rot13Strategy());\n\n\n\nWhen you use the hydrator to extract an array for the object \n$foo\n, you'll\nreceive the following:\n\n\n$extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }\n\n\n\nAnd when hydrating a new \nFoo\n instance:\n\n\n$hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Strategies"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy",
            "text": "You can compose  Zend\\Hydrator\\Strategy\\StrategyInterface  instances in any of\nthe hydrators to manipulate the way they behave on  extract()  and  hydrate() \nfor specific key/value pairs. The interface offers the following definitions:  namespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n    /**\n     * Converts the given value so that it can be extracted by the hydrator.\n     *\n     * @param  mixed       $value The original value.\n     * @param  null|object $object (optional) The original object for context.\n     * @return mixed       Returns the value that should be extracted.\n     */\n    public function extract($value, ?object $object = null);\n\n    /**\n     * Converts the given value so that it can be hydrated by the hydrator.\n     *\n     * @param  mixed      $value The original value.\n     * @param  null|array $data (optional) The original data for context.\n     * @return mixed      Returns the value that should be hydrated.\n     */\n    public function hydrate($value, ?array $data = null);\n}  This interface is similar to what the  Zend\\Hydrator\\ExtractionInterface  and Zend\\Hydrator\\HydrationInterface  provide; the reason is that strategies\nprovide a proxy implementation for  hydrate()  and  extract()  on individual\nvalues. For this reason, their return types are listed as mixed, versus as array  and  object , respectively.",
            "title": "Zend\\Hydrator\\Strategy"
        },
        {
            "location": "/v3/strategy/#adding-strategies-to-the-hydrators",
            "text": "This package provides the interface  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface .\nHydrators can implement this interface, and then call on its  getStrategy() \nmethod in order to extract or hydrate individual values. The interface has the\nfollowing definition:  namespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     */\n    public function addStrategy(string $name, StrategyInterface $strategy) : void;\n\n    /**\n     * Gets the strategy with the given name.\n     */\n    public function getStrategy(string $name) : StrategyInterface;\n\n    /**\n     * Checks if the strategy with the given name exists.\n     */\n    public function hasStrategy(string $name) : bool;\n\n    /**\n     * Removes the strategy with the given name.\n     */\n    public function removeStrategy(string $name) : void;\n}  We provide a default implementation of the interface as part of Zend\\Hydrator\\AbstractHydrator ; it uses an array property to store and\nretrieve strategies by name when extracting and hydrating values. Since all\nshipped hydrators are based on  AbstractHydrator , they share these\ncapabilities.  Additionally, the functionality that consumes strategies within AbstractHydrator  also contains checks if a naming strategy is composed, and,\nif present, will use it to translate the property name prior to looking up a\n  strategy for it.",
            "title": "Adding strategies to the hydrators"
        },
        {
            "location": "/v3/strategy/#available-implementations",
            "text": "",
            "title": "Available implementations"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92booleanstrategy",
            "text": "This strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for  true  and false .",
            "title": "Zend\\Hydrator\\Strategy\\BooleanStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92closurestrategy",
            "text": "This is a strategy that allows you to pass in options for:   hydrate , a callback to be called when hydrating a value, and  extract , a callback to be called when extracting a value.",
            "title": "Zend\\Hydrator\\Strategy\\ClosureStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92datetimeformatterstrategy",
            "text": "DateTimeFormatterStrategy  provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.  The strategy allows  DateTime  formats that use  !  to prepend the format, or |  or  +  to append it; these ensure that, during hydration, the new  DateTime \ninstance created will set the time element accordingly. As a specific example, Y-m-d|  will drop the time component, ensuring comparisons are based on a\nmidnight time value.  Starting in version 3.0, the constructor defines a third, optional argument, $dateTimeFallback .  If enabled and hydration fails, the given string is parsed\nby the  DateTime  constructor, as demonstrated below:  // Previous behavior:\n$strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP');\n$hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01'); // Format is the same; returns DateTime instance\n$hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01');        // Format is different; value is not hydrated\n\n// Using new $dateTimeFallback flag; both values are hydrated:\n$strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP', null, true);\n$hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01');\n$hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01');",
            "title": "Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92defaultstrategy",
            "text": "The  DefaultStrategy  simply proxies everything through, without performing any\nconversion of values.",
            "title": "Zend\\Hydrator\\Strategy\\DefaultStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92explodestrategy",
            "text": "This strategy is a wrapper around PHP's  implode()  and  explode()  functions.\nThe delimiter and a limit can be provided to the constructor; the limit will\nonly be used for  extract  operations.",
            "title": "Zend\\Hydrator\\Strategy\\ExplodeStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92serializablestrategy",
            "text": "SerializableStrategy  provides the functionality backing Zend\\Hydrator\\ArraySerializableHydrator . You can use it with custom\nimplementations for  Zend\\Serializer\\Adapter\\AdapterInterface  if you want to as\nwell.",
            "title": "Zend\\Hydrator\\Strategy\\SerializableStrategy"
        },
        {
            "location": "/v3/strategy/#zend92hydrator92strategy92strategychain",
            "text": "This strategy takes an array of  StrategyInterface  instances and iterates\nover them when performing  extract()  and  hydrate()  operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.",
            "title": "Zend\\Hydrator\\Strategy\\StrategyChain"
        },
        {
            "location": "/v3/strategy/#writing-custom-strategies",
            "text": "The following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing  str_rot13()  during both the  extract()  and  hydrate()  operations:  class Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}  This is the example class with which we want to use the hydrator example:  class Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}  Now, we'll add the  rot13  strategy to the method  getFoo()  and  setFoo($foo) :  $foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethodsHydrator();\n$hydrator->addStrategy('foo', new Rot13Strategy());  When you use the hydrator to extract an array for the object  $foo , you'll\nreceive the following:  $extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }  And when hydrating a new  Foo  instance:  $hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Writing custom strategies"
        },
        {
            "location": "/v3/aggregate/",
            "text": "AggregateHydrator\n\n\nZend\\Hydrator\\Aggregate\\AggregateHydrator\n is an implementation of\n\nZend\\Hydrator\\HydratorInterface\n that composes multiple hydrators via event listeners.\n\n\nYou typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.\n\n\nInstallation requirements\n\n\nThe \nAggregateHydrator\n depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:\n\n\n$ composer require zendframework/zend-eventmanager\n\n\n\nBasic usage\n\n\nA simple use case may be hydrating a \nBlogPost\n object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);\n\n\n\n\n\nHydrator priorities\n\n\nAggregateHydrator::add\n has a second optional argument, \n$priority\n. If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.\n\n\n\n\nIn order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:\n\n\nnamespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}\n\n\n\nAdvanced use cases\n\n\nSince the \nAggregateHydrator\n is event-driven, you can use the \nEventManager\n\nAPI to tweak its behaviour.\n\n\nCommon use cases include:\n\n\n\n\nRemoval of hydrated data keys (passwords/confidential information) depending\n  on business rules.\n\n\nCaching of the hydration/extraction process.\n\n\nTransformations on extracted data, for compatibility with third-party APIs.\n\n\n\n\nIn the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);\n\n\n\nWith an aggregate hydrator configured in this way, any\n\n$hydrator->extract($blogPost)\n operation will be cached.",
            "title": "Aggregates"
        },
        {
            "location": "/v3/aggregate/#aggregatehydrator",
            "text": "Zend\\Hydrator\\Aggregate\\AggregateHydrator  is an implementation of Zend\\Hydrator\\HydratorInterface  that composes multiple hydrators via event listeners.  You typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.",
            "title": "AggregateHydrator"
        },
        {
            "location": "/v3/aggregate/#installation-requirements",
            "text": "The  AggregateHydrator  depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:  $ composer require zendframework/zend-eventmanager",
            "title": "Installation requirements"
        },
        {
            "location": "/v3/aggregate/#basic-usage",
            "text": "A simple use case may be hydrating a  BlogPost  object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);",
            "title": "Basic usage"
        },
        {
            "location": "/v3/aggregate/#hydrator-priorities",
            "text": "AggregateHydrator::add  has a second optional argument,  $priority . If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.   In order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:  namespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}",
            "title": "Hydrator priorities"
        },
        {
            "location": "/v3/aggregate/#advanced-use-cases",
            "text": "Since the  AggregateHydrator  is event-driven, you can use the  EventManager \nAPI to tweak its behaviour.  Common use cases include:   Removal of hydrated data keys (passwords/confidential information) depending\n  on business rules.  Caching of the hydration/extraction process.  Transformations on extracted data, for compatibility with third-party APIs.   In the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);  With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost)  operation will be cached.",
            "title": "Advanced use cases"
        },
        {
            "location": "/v3/naming-strategy/intro/",
            "text": "Naming Strategies\n\n\nSometimes, the representation of a property should not share the same name as\nthe property itself. As an example, when serializing an object for a JSON\npayload, you may want to convert camelCase properties to underscore_separated\nproperties, and vice versa when deserializing JSON to an object.\n\n\nTo make that possible, zend-hydrator provides \nnaming strategies\n. These are\nsimilar to \nstrategies\n, but instead of operating on the\n\nvalue\n, they operate on the \nname\n.\n\n\nNamingStrategyInterface\n\n\nNaming strategies implement \nZend\\Hydrator\\NamingStrategy\\NamingStrategyInterface\n:\n\n\nnamespace Zend\\Hydrator\\NamingStrategy;\n\n/**\n * Allow property extraction / hydration for hydrator\n */\ninterface NamingStrategyInterface\n{\n    /**\n     * Converts the given name so that it can be extracted by the hydrator.\n     *\n     * @param null|mixed[] $data The original data for context.\n     */\n    public function hydrate(string $name, ?array $data = null) : string;\n\n    /**\n     * Converts the given name so that it can be hydrated by the hydrator.\n     *\n     * @param null|object $object The original object for context.\n     */\n    public function extract(string $name, ?object $object = null) : string;\n}\n\n\n\nProviding naming strategies\n\n\nHydrators can indicate they will consume naming strategies, as well as allow\nregistration of them, by implementing \nZend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface\n:\n\n\nnamespace Zend\\Hydrator\\NamingStrategy;\n\ninterface NamingStrategyEnabledInterface\n{\n    /**\n     * Sets the naming strategy.\n     */\n    public function setNamingStrategy(NamingStrategyInterface $strategy) : void;\n\n    /**\n     * Gets the naming strategy.\n     */\n    public function getNamingStrategy() : NamingStrategyInterface;\n\n    /**\n     * Checks if a naming strategy exists.\n     */\n    public function hasNamingStrategy() : bool;\n\n    /**\n     * Removes the naming strategy.\n     */\n    public function removeNamingStrategy() : void;\n}\n\n\n\nWe provide a default implementation of this interface within the\n\nZend\\Hydrator\\AbstractHydrator\n definition. Its \ngetNamingStrategy()\n will\nlazy-load an \nIdentityNamingStrategy\n if none has been previously registered.\nSince all shipped hydrators extend \nAbstractHydrator\n, they can consume naming\nstrategies.\n\n\nShipped naming strategies\n\n\nWe provide the following naming strategies:\n\n\n\n\nCompositeNamingStrategy\n\n\nIdentityNamingStrategy\n\n\nMapNamingStrategy\n\n\nUnderscoreNamingStrategy",
            "title": "Introduction"
        },
        {
            "location": "/v3/naming-strategy/intro/#naming-strategies",
            "text": "Sometimes, the representation of a property should not share the same name as\nthe property itself. As an example, when serializing an object for a JSON\npayload, you may want to convert camelCase properties to underscore_separated\nproperties, and vice versa when deserializing JSON to an object.  To make that possible, zend-hydrator provides  naming strategies . These are\nsimilar to  strategies , but instead of operating on the value , they operate on the  name .",
            "title": "Naming Strategies"
        },
        {
            "location": "/v3/naming-strategy/intro/#namingstrategyinterface",
            "text": "Naming strategies implement  Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface :  namespace Zend\\Hydrator\\NamingStrategy;\n\n/**\n * Allow property extraction / hydration for hydrator\n */\ninterface NamingStrategyInterface\n{\n    /**\n     * Converts the given name so that it can be extracted by the hydrator.\n     *\n     * @param null|mixed[] $data The original data for context.\n     */\n    public function hydrate(string $name, ?array $data = null) : string;\n\n    /**\n     * Converts the given name so that it can be hydrated by the hydrator.\n     *\n     * @param null|object $object The original object for context.\n     */\n    public function extract(string $name, ?object $object = null) : string;\n}",
            "title": "NamingStrategyInterface"
        },
        {
            "location": "/v3/naming-strategy/intro/#providing-naming-strategies",
            "text": "Hydrators can indicate they will consume naming strategies, as well as allow\nregistration of them, by implementing  Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface :  namespace Zend\\Hydrator\\NamingStrategy;\n\ninterface NamingStrategyEnabledInterface\n{\n    /**\n     * Sets the naming strategy.\n     */\n    public function setNamingStrategy(NamingStrategyInterface $strategy) : void;\n\n    /**\n     * Gets the naming strategy.\n     */\n    public function getNamingStrategy() : NamingStrategyInterface;\n\n    /**\n     * Checks if a naming strategy exists.\n     */\n    public function hasNamingStrategy() : bool;\n\n    /**\n     * Removes the naming strategy.\n     */\n    public function removeNamingStrategy() : void;\n}  We provide a default implementation of this interface within the Zend\\Hydrator\\AbstractHydrator  definition. Its  getNamingStrategy()  will\nlazy-load an  IdentityNamingStrategy  if none has been previously registered.\nSince all shipped hydrators extend  AbstractHydrator , they can consume naming\nstrategies.",
            "title": "Providing naming strategies"
        },
        {
            "location": "/v3/naming-strategy/intro/#shipped-naming-strategies",
            "text": "We provide the following naming strategies:   CompositeNamingStrategy  IdentityNamingStrategy  MapNamingStrategy  UnderscoreNamingStrategy",
            "title": "Shipped naming strategies"
        },
        {
            "location": "/v3/naming-strategy/identity-naming-strategy/",
            "text": "IdentityNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy\n uses the keys provided to\nit for hydration and extraction.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar\n\n\n\nThis strategy can be used in hydrators as well:\n\n\nclass Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Identity"
        },
        {
            "location": "/v3/naming-strategy/identity-naming-strategy/#identitynamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy  uses the keys provided to\nit for hydration and extraction.",
            "title": "IdentityNamingStrategy"
        },
        {
            "location": "/v3/naming-strategy/identity-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar  This strategy can be used in hydrators as well:  class Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/",
            "text": "MapNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\MapNamingStrategy\n allows you to provide a map of\nkeys to use both during extraction and hydration; the map will translate the key\nbased on the direction:\n\n\n\n\n\n\nWhen a map is provided for hydration, but not extraction, the strategy will\n  perform an \narray_flip\n on the hydration map when performing lookups.\n  You can create an instance with this behavior using\n  \nMapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy\n.\n\n\n\n\n\n\nWhen a map is provided for extraction, but not hydration, the strategy will\n  perform an \narray_flip\n on the extraction map when performing lookups.\n  You can create an instance with this behavior using\n  \nMapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy\n.\n\n\n\n\n\n\nWhen maps are provided for both extraction and hydration, the appropriate map\n  will be used during extraction and hydration operations. You can create an\n  instance with this behavior using\n  \nMapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy\n.\n\n\n\n\n\n\nMost of the time, you will want your maps symmetrical; as such, set either a\nhydration map or an extraction map, but not both.\n\n\nCreating maps\n\n\nHydration map only\n\n\n$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap(\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ]\n);\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz\n\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash\n\n\n\nExtraction map only\n\n\n$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromExtractionMap(\n    null, // no hydration map\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ]\n);\necho $namingStrategy->extract('foo'); // outputs: bar\necho $namingStrategy->extract('baz'); // outputs: bash\n\necho $namingStrategy->hydrate('bar'); // outputs: foo\necho $namingStrategy->hydrate('bash'); // outputs: baz\n\n\n\nBoth hydration and extraction maps\n\n\n$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromAsymmetricMap(\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ],\n    [\n        'is_bar'   => 'foo',\n        'bashable' => 'baz',\n    ]\n);\necho $namingStrategy->extract('foo'); // outputs: bar\necho $namingStrategy->extract('baz'); // outputs: bash\n\necho $namingStrategy->hydrate('is_bar'); // outputs: foo\necho $namingStrategy->hydrate('bashable'); // outputs: baz\n\n\n\nMapping keys for hydrators\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped:\n\n\nclass Foo\n{\n    public $bar;\n}\n\n$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([\n    'foo' => 'bar',\n    'baz' => 'bash',\n]);\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( \"foo\" => 123 )",
            "title": "Mapping"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#mapnamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy  allows you to provide a map of\nkeys to use both during extraction and hydration; the map will translate the key\nbased on the direction:    When a map is provided for hydration, but not extraction, the strategy will\n  perform an  array_flip  on the hydration map when performing lookups.\n  You can create an instance with this behavior using\n   MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy .    When a map is provided for extraction, but not hydration, the strategy will\n  perform an  array_flip  on the extraction map when performing lookups.\n  You can create an instance with this behavior using\n   MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy .    When maps are provided for both extraction and hydration, the appropriate map\n  will be used during extraction and hydration operations. You can create an\n  instance with this behavior using\n   MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy .    Most of the time, you will want your maps symmetrical; as such, set either a\nhydration map or an extraction map, but not both.",
            "title": "MapNamingStrategy"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#creating-maps",
            "text": "",
            "title": "Creating maps"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#hydration-map-only",
            "text": "$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap(\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ]\n);\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz\n\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash",
            "title": "Hydration map only"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#extraction-map-only",
            "text": "$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromExtractionMap(\n    null, // no hydration map\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ]\n);\necho $namingStrategy->extract('foo'); // outputs: bar\necho $namingStrategy->extract('baz'); // outputs: bash\n\necho $namingStrategy->hydrate('bar'); // outputs: foo\necho $namingStrategy->hydrate('bash'); // outputs: baz",
            "title": "Extraction map only"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#both-hydration-and-extraction-maps",
            "text": "$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromAsymmetricMap(\n    [\n        'foo' => 'bar',\n        'baz' => 'bash'\n    ],\n    [\n        'is_bar'   => 'foo',\n        'bashable' => 'baz',\n    ]\n);\necho $namingStrategy->extract('foo'); // outputs: bar\necho $namingStrategy->extract('baz'); // outputs: bash\n\necho $namingStrategy->hydrate('is_bar'); // outputs: foo\necho $namingStrategy->hydrate('bashable'); // outputs: baz",
            "title": "Both hydration and extraction maps"
        },
        {
            "location": "/v3/naming-strategy/map-naming-strategy/#mapping-keys-for-hydrators",
            "text": "This strategy can be used in hydrators to dictate how keys should be mapped:  class Foo\n{\n    public $bar;\n}\n\n$namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([\n    'foo' => 'bar',\n    'baz' => 'bash',\n]);\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( \"foo\" => 123 )",
            "title": "Mapping keys for hydrators"
        },
        {
            "location": "/v3/naming-strategy/underscore-naming-strategy/",
            "text": "UnderscoreNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\n converts snake case strings (e.g.\n\nfoo_bar_baz\n) to camel-case strings (e.g. \nfooBarBaz\n) and vice versa.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar\n\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped.\n\n\nclass Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Underscore Mapping"
        },
        {
            "location": "/v3/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy  converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g.  fooBarBaz ) and vice versa.",
            "title": "UnderscoreNamingStrategy"
        },
        {
            "location": "/v3/naming-strategy/underscore-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar  This strategy can be used in hydrators to dictate how keys should be mapped.  class Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v3/naming-strategy/composite-naming-strategy/",
            "text": "CompositeNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy\n allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.\n\n\nBasic Usage\n\n\nWhen invoked, the following composite strategy will extract the property \nbar\n\nto the array key \nfoo\n (using the \nMapNamingStrategy\n), and the property\n\nbarBat\n to the array key \nbar_bat\n (using the \nUnderscoreNamingStrategy\n):\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n\n\nUnfortunately, the \nCompositeNamingStrategy\n can only be used for extraction as it will not know how\nto handle the keys necessary for hydration (\nfoo\n and \nbar_bat\n, respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Composite"
        },
        {
            "location": "/v3/naming-strategy/composite-naming-strategy/#compositenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy  allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.",
            "title": "CompositeNamingStrategy"
        },
        {
            "location": "/v3/naming-strategy/composite-naming-strategy/#basic-usage",
            "text": "When invoked, the following composite strategy will extract the property  bar \nto the array key  foo  (using the  MapNamingStrategy ), and the property barBat  to the array key  bar_bat  (using the  UnderscoreNamingStrategy ):  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 )  Unfortunately, the  CompositeNamingStrategy  can only be used for extraction as it will not know how\nto handle the keys necessary for hydration ( foo  and  bar_bat , respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v3/plugin-managers/",
            "text": "Plugin Managers\n\n\nIt can be useful to compose a plugin manager from which you can retrieve\nhydrators; in fact, \nZend\\Hydrator\\DelegatingHydrator\n does exactly that!\nWith such a manager, you can retrieve instances using short names, or instances\nthat have dependencies on other services, without needing to know the details of\nhow that works.\n\n\nExamples of Hydrator plugin managers in real-world scenarios include:\n\n\n\n\nhydrating database result sets\n\n\npreparing API payloads\n\n\n\n\nHydratorPluginManagerInterface\n\n\nWe provide two plugin manager implementations. Essentially, they only need to\nimplement the \nPSR-11 ContainerInterface\n,\nbut plugin managers in current versions of \nzend-servicemanager\n\nonly implement it indirectly via the container-interop project.\n\n\nAs such, we ship \nZend\\Hydrator\\HydratorPluginManagerInterface\n, which simply\nextends the PSR-11 \nPsr\\Container\\ContainerInterface\n. Each of our\nimplementations implement it.\n\n\nHydratorPluginManager\n\n\nIf you have used zend-hydrator prior to version 3, you are likely already\nfamiliar with this class, as it has been the implementation we have shipped from\ninitial versions. The \nHydratorPluginManager\n extends the zend-servicemanager\n\nAbstractPluginManager\n, and has the following behaviors:\n\n\n\n\nIt will only return \nZend\\Hydrator\\HydratorInterface\n instances.\n\n\nIt defines short-name aliases for all shipped hydrators (the class name minus\n  the namespace), in a variety of casing combinations.\n\n\nAll but the \nDelegatingHydrator\n are defined as invokable services (meaning\n  they can be instantiated without any constructor arguments).\n\n\nThe \nDelegatingHydrator\n is configured as a factory-based service, mapping to\n  the \nZend\\Hydrator\\DelegatingHydratorFactory\n.\n\n\nNo services are shared; a new instance is created each time you call \nget()\n.\n\n\n\n\nHydratorPluginManagerFactory\n\n\nZend\\Hydrator\\HydratorPluginManager\n is mapped to the factory\n\nZend\\Hydrator\\HydratorPluginManagerFactory\n when wired to the dependency\ninjection container.\n\n\nThe factory will look for the \nconfig\n service, and use the \nhydrators\n\nconfiguration key to seed it with additional services. This configuration key\nshould map to an array that follows \nstandard zend-servicemanager configuration\n.\n\n\nStandaloneHydratorPluginManager\n\n\nZend\\Hydrator\\StandaloneHydratorPluginManager\n provides an implementation that\nhas no dependencies on other libraries. \nIt can only load the hydrators shipped\nwith zend-hydrator\n.\n\n\nStandardHydratorPluginManagerFactory\n\n\nZend\\Hydrator\\StandardHydratorPluginManager\n is mapped to the factory\n\nZend\\Hydrator\\StandardHydratorPluginManagerFactory\n when wired to the dependency\ninjection container.\n\n\nHydratorManager alias\n\n\nZend\\Hydrator\\ConfigManager\n defines an alias service, \nHydratorManager\n. That\nservice will point to \nZend\\Hydrator\\HydratorPluginManager\n if\nzend-servicemanager is installed, and \nZend\\Hydrator\\StandaloneHydratorPluginManager\n\notherwise.\n\n\nCustom plugin managers\n\n\nIf you do not want to use zend-servicemanager, but want a plugin manager that is\ncustomizable, or at least capable of loading the hydrators you have defined for\nyour application, you should write a custom implementation of\n\nZend\\Hydrator\\HydratorPluginManagerInterface\n, and wire it to the\n\nHydratorManager\n service, and/or one of the existing service names.\n\n\nAs an example, if you want a configurable solution that uses factories, and want\nthose factories capable of pulling application-level dependencies, you might do\nsomething like the following:\n\n\n// In src/YourApplication/CustomHydratorPluginManager.php:\n\nnamespace YourApplication;\n\nuse Psr\\Container\\NotFoundExceptionInterface;\nuse Psr\\Container\\ContainerInterface;\nuse RuntimeException;\nuse Zend\\Hydrator\\HydratorInterface;\nuse Zend\\Hydrator\\HydratorPluginManagerInterface;\nuse Zend\\Hydrator\\StandaloneHydratorPluginManager;\n\nclass CustomHydratorPluginManager implements HydratorPluginManagerInterface\n{\n    /** @var ContainerInterface */\n    private $appContainer;\n\n    /** @var StandaloneHydratorPluginManager */\n    private $defaults;\n\n    /** @var array<string, string|callable> */\n    private $factories = [];\n\n    public function __construct(ContainerInterface $appContainer)\n    {\n        $this->appContainer = $appContainer;\n        $this->defaults = new StandaloneHydratorPluginManager();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function get($id) : HydratorInterface\n    {\n        if (! isset($this->factories[$id]) && ! $this->defaults->has($id)) {\n            $message = sprintf('Hydrator service %s not found', $id);\n            throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {};\n        }\n\n        // Default was requested; fallback to standalone container\n        if (! isset($this->factories[$id])) {\n            return $this->defaults->get($id);\n        }\n\n        $factory = $this->factories[$id];\n        if (is_string($factory)) {\n            $this->factories[$id] = $factory = new $factory();\n        }\n\n        return $factory($this->appContainer, $id);\n    }\n\n    public function has($id) : bool\n    {\n        return isset($this->factories[$id]) || $this->defaults->has($id);\n    }\n\n    public function setFactoryClass(string $name, string $factory) : void\n    {\n        $this->factories[$name] = $factory;\n    }\n\n    public function setFactory(string $name, callable $factory) : void\n    {\n        $this->factories[$name] = $factory;\n    }\n}\n\n\n\n// In src/YourApplication/CustomHydratorPluginManagerFactory.php:\n\nnamespace YourApplication;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass CustomHydratorPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager\n    {\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = $config['hydrators']['factories'] ?? [];\n\n        $manager = new CustomHydratorPluginManager($this);\n\n        if ([] !== $config) {\n            $this->configureManager($manager, $config);\n        }\n\n        return $manager;\n    }\n\n    /**\n     * @param array<string, string|callable> $config\n     */\n    private function configureManager(CustomHydratorPluginManager $manager, array $config) : void\n    {\n        foreach ($config as $name => $factory) {\n            is_string($factory)\n                ? $manager->setFactoryClass($name, $factory)\n                : $manager->setFactory($name, $factory);\n        }\n    }\n}\n\n\n\n// in config/autoload/hydrators.global.php or similar:\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'HydratorManager' => \\YourApplication\\CustomHydratorPluginManager::class,\n        ],\n        'factories' => [\n            \\YourApplication\\CustomHydratorPluginManager::class => \\YourApplication\\CustomHydratorPluginManagerFactory::class\n        ],\n    ],\n    'hydrators' => [\n        'factories' => [\n            \\Blog\\PostHydrator::class => \\Blog\\PostHydratorFactory::class,\n            \\News\\ItemHydrator::class => \\News\\ItemHydratorFactory::class,\n            // etc.\n        ],\n    ],\n];",
            "title": "Plugin Managers"
        },
        {
            "location": "/v3/plugin-managers/#plugin-managers",
            "text": "It can be useful to compose a plugin manager from which you can retrieve\nhydrators; in fact,  Zend\\Hydrator\\DelegatingHydrator  does exactly that!\nWith such a manager, you can retrieve instances using short names, or instances\nthat have dependencies on other services, without needing to know the details of\nhow that works.  Examples of Hydrator plugin managers in real-world scenarios include:   hydrating database result sets  preparing API payloads",
            "title": "Plugin Managers"
        },
        {
            "location": "/v3/plugin-managers/#hydratorpluginmanagerinterface",
            "text": "We provide two plugin manager implementations. Essentially, they only need to\nimplement the  PSR-11 ContainerInterface ,\nbut plugin managers in current versions of  zend-servicemanager \nonly implement it indirectly via the container-interop project.  As such, we ship  Zend\\Hydrator\\HydratorPluginManagerInterface , which simply\nextends the PSR-11  Psr\\Container\\ContainerInterface . Each of our\nimplementations implement it.",
            "title": "HydratorPluginManagerInterface"
        },
        {
            "location": "/v3/plugin-managers/#hydratorpluginmanager",
            "text": "If you have used zend-hydrator prior to version 3, you are likely already\nfamiliar with this class, as it has been the implementation we have shipped from\ninitial versions. The  HydratorPluginManager  extends the zend-servicemanager AbstractPluginManager , and has the following behaviors:   It will only return  Zend\\Hydrator\\HydratorInterface  instances.  It defines short-name aliases for all shipped hydrators (the class name minus\n  the namespace), in a variety of casing combinations.  All but the  DelegatingHydrator  are defined as invokable services (meaning\n  they can be instantiated without any constructor arguments).  The  DelegatingHydrator  is configured as a factory-based service, mapping to\n  the  Zend\\Hydrator\\DelegatingHydratorFactory .  No services are shared; a new instance is created each time you call  get() .",
            "title": "HydratorPluginManager"
        },
        {
            "location": "/v3/plugin-managers/#hydratorpluginmanagerfactory",
            "text": "Zend\\Hydrator\\HydratorPluginManager  is mapped to the factory Zend\\Hydrator\\HydratorPluginManagerFactory  when wired to the dependency\ninjection container.  The factory will look for the  config  service, and use the  hydrators \nconfiguration key to seed it with additional services. This configuration key\nshould map to an array that follows  standard zend-servicemanager configuration .",
            "title": "HydratorPluginManagerFactory"
        },
        {
            "location": "/v3/plugin-managers/#standalonehydratorpluginmanager",
            "text": "Zend\\Hydrator\\StandaloneHydratorPluginManager  provides an implementation that\nhas no dependencies on other libraries.  It can only load the hydrators shipped\nwith zend-hydrator .",
            "title": "StandaloneHydratorPluginManager"
        },
        {
            "location": "/v3/plugin-managers/#standardhydratorpluginmanagerfactory",
            "text": "Zend\\Hydrator\\StandardHydratorPluginManager  is mapped to the factory Zend\\Hydrator\\StandardHydratorPluginManagerFactory  when wired to the dependency\ninjection container.",
            "title": "StandardHydratorPluginManagerFactory"
        },
        {
            "location": "/v3/plugin-managers/#hydratormanager-alias",
            "text": "Zend\\Hydrator\\ConfigManager  defines an alias service,  HydratorManager . That\nservice will point to  Zend\\Hydrator\\HydratorPluginManager  if\nzend-servicemanager is installed, and  Zend\\Hydrator\\StandaloneHydratorPluginManager \notherwise.",
            "title": "HydratorManager alias"
        },
        {
            "location": "/v3/plugin-managers/#custom-plugin-managers",
            "text": "If you do not want to use zend-servicemanager, but want a plugin manager that is\ncustomizable, or at least capable of loading the hydrators you have defined for\nyour application, you should write a custom implementation of Zend\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager  service, and/or one of the existing service names.  As an example, if you want a configurable solution that uses factories, and want\nthose factories capable of pulling application-level dependencies, you might do\nsomething like the following:  // In src/YourApplication/CustomHydratorPluginManager.php:\n\nnamespace YourApplication;\n\nuse Psr\\Container\\NotFoundExceptionInterface;\nuse Psr\\Container\\ContainerInterface;\nuse RuntimeException;\nuse Zend\\Hydrator\\HydratorInterface;\nuse Zend\\Hydrator\\HydratorPluginManagerInterface;\nuse Zend\\Hydrator\\StandaloneHydratorPluginManager;\n\nclass CustomHydratorPluginManager implements HydratorPluginManagerInterface\n{\n    /** @var ContainerInterface */\n    private $appContainer;\n\n    /** @var StandaloneHydratorPluginManager */\n    private $defaults;\n\n    /** @var array<string, string|callable> */\n    private $factories = [];\n\n    public function __construct(ContainerInterface $appContainer)\n    {\n        $this->appContainer = $appContainer;\n        $this->defaults = new StandaloneHydratorPluginManager();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function get($id) : HydratorInterface\n    {\n        if (! isset($this->factories[$id]) && ! $this->defaults->has($id)) {\n            $message = sprintf('Hydrator service %s not found', $id);\n            throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {};\n        }\n\n        // Default was requested; fallback to standalone container\n        if (! isset($this->factories[$id])) {\n            return $this->defaults->get($id);\n        }\n\n        $factory = $this->factories[$id];\n        if (is_string($factory)) {\n            $this->factories[$id] = $factory = new $factory();\n        }\n\n        return $factory($this->appContainer, $id);\n    }\n\n    public function has($id) : bool\n    {\n        return isset($this->factories[$id]) || $this->defaults->has($id);\n    }\n\n    public function setFactoryClass(string $name, string $factory) : void\n    {\n        $this->factories[$name] = $factory;\n    }\n\n    public function setFactory(string $name, callable $factory) : void\n    {\n        $this->factories[$name] = $factory;\n    }\n}  // In src/YourApplication/CustomHydratorPluginManagerFactory.php:\n\nnamespace YourApplication;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass CustomHydratorPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager\n    {\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = $config['hydrators']['factories'] ?? [];\n\n        $manager = new CustomHydratorPluginManager($this);\n\n        if ([] !== $config) {\n            $this->configureManager($manager, $config);\n        }\n\n        return $manager;\n    }\n\n    /**\n     * @param array<string, string|callable> $config\n     */\n    private function configureManager(CustomHydratorPluginManager $manager, array $config) : void\n    {\n        foreach ($config as $name => $factory) {\n            is_string($factory)\n                ? $manager->setFactoryClass($name, $factory)\n                : $manager->setFactory($name, $factory);\n        }\n    }\n}  // in config/autoload/hydrators.global.php or similar:\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'HydratorManager' => \\YourApplication\\CustomHydratorPluginManager::class,\n        ],\n        'factories' => [\n            \\YourApplication\\CustomHydratorPluginManager::class => \\YourApplication\\CustomHydratorPluginManagerFactory::class\n        ],\n    ],\n    'hydrators' => [\n        'factories' => [\n            \\Blog\\PostHydrator::class => \\Blog\\PostHydratorFactory::class,\n            \\News\\ItemHydrator::class => \\News\\ItemHydratorFactory::class,\n            // etc.\n        ],\n    ],\n];",
            "title": "Custom plugin managers"
        },
        {
            "location": "/v3/migration/",
            "text": "Migration from version 2\n\n\nThis document details changes made between version 2 and version 3 that could\naffect end-users.\n\n\nMinimum supported versions\n\n\nPHP\n\n\nVersion 3 bumps the minimum supported PHP version to version 7.2. We chose this\nversion in particular as it provides the \nobject\n typehint, which allows us to\nenforce at the engine level what we were previously enforcing only at the\ndocumentation level.\n\n\nAdditionally, we have enabled strict types in all class files shipped with this\ncomponent.\n\n\nzend-eventmanager\n\n\nThe minimum supported version of zend-eventmanager (used by the\n\nAggregateHydrator\n)is now 3.2.1.\n\n\nzend-serializer\n\n\nThe minimum supported version of zend-serializer (used by the\n\nSerializableStrategy\n) is now 2.9.0.\n\n\nzend-servicemanager\n\n\nThe minimum supported version of zend-servicemanager (used by the\n\nHydratorPluginManager\n) is now 3.3.2.\n\n\nRenamed interfaces\n\n\nThe following interfaces were renamed:\n\n\n\n\nZend\\Hydrator\\FilterEnabledInterface\n becomes \nZend\\Hydrator\\Filter\\FilterEnabledInterface\n.\n\n\nZend\\Hydrator\\NamingStrategyEnabledInterface\n becomes \nZend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface\n.\n\n\nZend\\Hydrator\\StrategyEnabledInterface\n becomes \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n.\n\n\n\n\nRenamed classes\n\n\nThe following classes were renamed:\n\n\n\n\nZend\\Hydrator\\ArraySerializable\n becomes \nZend\\Hydrator\\ArraySerializableHydrator\n\n\nZend\\Hydrator\\ClassMethods\n becomes \nZend\\Hydrator\\ClassMethodsHydrator\n\n\nZend\\Hydrator\\ObjectProperty\n becomes \nZend\\Hydrator\\ObjectPropertyHydrator\n\n\nZend\\Hydrator\\Reflection\n becomes \nZend\\Hydrator\\ReflectionHydrator\n\n\n\n\nIn each case, a class named after the original has been created as a deprecated\nextension of the new class. This means you can continue to use the old class\nnames, but only until version 4, at which point they will be removed.\n\n\nAdditionally, aliases for the old class names have been added to the\n\nHydratorPluginManager\n, pointing to services named after the new class names.\n\n\nInterface changes\n\n\nEach of the interfaces provided by this package have been updated to add\ntypehints where they were previously omitted (due to engine limitations), both\non parameters and return values. These include:\n\n\n\n\nZend\\Hydrator\\ExtractionInterface\n:\n\n\nextract($object)\n becomes \nextract(object $object) : array\n\n\nZend\\Hydrator\\Filter\\FilterEnabledInterface\n (was \nZend\\Hydrator\\FilterEnabledInterface\n):\n\n\naddFilter($name, $filter, $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR)\n becomes \naddFilter(string $name, $filter, int $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void\n\n\nhasFilter($name)\n becomes \nhasFilter(string $name) : bool\n\n\nremoveFilter($name)\n becomes \nremoveFilter(string $name) : void\n\n\nZend\\Hydrator\\HydrationInterface\n:\n\n\nhydrate(array $data, $object)\n becomes \nhydrate(array $data, object $object)\n\n\nZend\\Hydrator\\HydratorAwareInterface\n:\n\n\nsetHydrator(Zend\\Hydrator\\HydratorInterface $hydrator)\n becomes \nsetHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void\n\n\ngetHydrator()\n becomes \ngetHydrator() : ?Zend\\Hydrator\\HydratorInterface\n\n\nZend\\Hydrator\\HydratorAwareTrait\n was updated to follow the interface; if\n    you use the trait to implement the interface, no changes will be necessary.\n\n\nZend\\Hydrator\\HydratorOptionsInterface\n:\n\n\nsetOptions($options)\n becomes \nsetOptions(iterable $options) : void\n\n\nZend\\Hydrator\\HydratorProviderInterface\n:\n\n\ngetHydratorConfig()\n becomes \ngetHydratorConfig() : array\n\n\nZend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface\n (was \nZend\\Hydrator\\NamingStrategyEnabledInterface\n):\n\n\nsetNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy)\n becomes \nsetNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void\n\n\ngetNamingStrategy()\n becomes \ngetNamingStrategy() : Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface\n\n\nremoveNamingStrategy()\n becomes \nremoveNamingStrategy() : void\n\n\nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n (was \nZend\\Hydrator\\StrategyEnabledInterface\n):\n\n\naddStrategy($name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy)\n becomes \naddStrategy(string $name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) : void\n\n\ngetStrategy($name)\n becomes \ngetStrategy(string $name) : Zend\\Hydrator\\Strategy\\StrategyInterface\n\n\nhasStrategy($name)\n becomes \nhasStrategy(string $name) : bool\n\n\nremoveStrategy($name)\n becomes \nremoveStrategy(string $name) : void\n\n\nZend\\Hydrator\\Filter\\FilterInterface\n:\n\n\nfilter($property)\n becomes \nfilter(string $property) : bool\n\n\nZend\\Hydrator\\Filter\\FilterProviderInterface\n:\n\n\ngetFilter()\n becomes \ngetFilter() : Zend\\Hydrator\\Filter\\FilterInterface\n\n\nZend\\Hydrator\\Iterator\\HydratingIteratorInterface\n:\n\n\nsetPrototype($prototype)\n becomes \nsetPrototype($prototype) : void\n (\n$prototype\n continues to allow either a \nstring\n or object)\n\n\nsetHydrator(Zend\\Hydrator\\HydratorInterface $hydrator)\n becomes \nsetHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void\n\n\nZend\\Hydrator\\NamingStrategy\\NamingStrategyInterface\n:\n\n\nextract($name)\n becomes \nextract(string $name, ?object $object = null) : string\n\n\nhydrate($name)\n becomes \nhydrate(string $name, ?array $data = null) : string\n\n\nZend\\Hydrator\\Strategy\\StrategyInterface\n:\n\n\nhydrate($value)\n becomes \nhydrate($value, ?array $data = null)\n (the \n$value\n parameter and return value can be any PHP type)\n\n\nextract($value)\n becomes \nextract($value, ?object $object = null)\n (the \n$value\n parameter and return value can be any PHP type)\n\n\n\n\nAll implementations of these interface shipped in the component have been\nupdated to ensure signatures match.\n\n\nIf you are providing custom implementations, or extending the implementations\nprovided in this package, you may need to update signatures per the above.\n\n\nTypehints\n\n\nAs noted in the above section, typehints were added to all interfaces. In\naddition to those changes, the following methods were also updated to add\ntypehints:\n\n\n\n\nZend\\Hydrator\\Aggregate\\AggregateHydrator\n:\n\n\n\n\nadd(Zend\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY)\n becomes \nadd(Zend\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void\n\n\n\n\n\n\nZend\\Hydrator\\Aggregate\\ExtractEvent\n:\n\n\n\n\n__construct($target, $extractionObject)\n becomes \n__construct(object $target, object $extractionObject)\n\n\ngetExtractionObject()\n becomes \ngetExtractionObject() : object\n\n\nsetExtractionObject($extractionObject)\n becomes \nsetExtractionObject(object $extractionObject) : void\n\n\ngetExtractedData()\n becomes \ngetExtractedData() : array\n\n\nsetExtractedData(array $extractedData)\n becomes \nsetExtractedData(array $extractedData) : void\n\n\n\n\nmergeExtractedData(array $additionalData)\n becomes \nmergeExtractedData(array $additionalData) : void\n\n\n\n\n\n\nZend\\Hydrator\\Aggregate\\HydrateEvent\n:\n\n\n\n\n__construct($target, $hydratedObject, array $hydrationData)\n becomes \n__construct(object $target, object $hydratedObject, array $hydrationData)\n\n\ngetHydratedObject()\n becomes \ngetHydratedObject() : object\n\n\nsetHydratedObject($hydratedObject)\n becomes \nsetHydratedObject(object $hydratedObject) : void\n\n\ngetHydrationData()\n becomes \ngetHydrationData() : array\n\n\n\n\nsetHydrationData(array $hydrationData)\n becomes \nsetHydrationData(array $hydrationData) : void\n\n\n\n\n\n\nZend\\Hydrator\\Aggregate\\HydratorListener\n:\n\n\n\n\nonHydrate(HydrateEvent $event)\n becomes \nonHydrate(HydrateEvent $event) : object\n\n\n\n\nonExtract(ExtractEvent $event)\n becomes \nonExtract(ExtractEvent $event) : array\n\n\n\n\n\n\nZend\\Hydrator\\ClassMethodsHydrator\n (was \nZend\\Hydrator\\ClassMethods\n):\n\n\n\n\n__construct($underscoreSeparatedKeys = true, $methodExistsCheck = false)\n becomes \n__construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false)\n\n\nsetUnderscoreSeparatedKeys($underscoreSeparatedKeys)\n becomes \nsetUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void\n\n\ngetUnderscoreSeparatedKeys()\n becomes \ngetUnderscoreSeparatedKeys() : bool\n\n\nsetMethodExistsCheck($methodExistsCheck)\n becomes \nsetMethodExistsCheck(bool $methodExistsCheck) : void\n\n\n\n\ngetMethodExistsCheck()\n becomes \ngetMethodExistsCheck() : bool\n\n\n\n\n\n\nZend\\Hydrator\\ConfigProvider\n:\n\n\n\n\n__invoke()\n becomes \n__invoke() : array\n\n\n\n\ngetDependencyConfig()\n becomes \ngetDependencyConfig() : array\n\n\n\n\n\n\nZend\\Hydrator\\DelegatingHydratorFactory\n:\n\n\n\n\nno longer implements \nZend\\ServiceManager\\FactoryInterface\n\n\n\n\n__invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null)\n becomes \n__invoke(Psr\\Container\\ContainerInterface $container) : Zend\\Hydrator\\DelegatingHydrator\n\n\n\n\n\n\nZend\\Hydrator\\Filter\\FilterComposite\n:\n\n\n\n\n\n\n__construct($orFilters = [], $andFilters = [])\n becomes \n__construct(array $orFilters = [], array $andFilters = [])\n\n\n\n\n\n\nZend\\Hydrator\\Filter\\MethodMatchFilter\n:\n\n\n\n\n\n\n__construct($method, $exclude = true)\n becomes \n__construct(string $method, bool $exclude = true)\n\n\n\n\n\n\nZend\\Hydrator\\Filter\\NumberOfParameterFilter\n:\n\n\n\n\n\n\n__construct($numberOfParameters = 0)\n becomes \n__construct(int $numberOfParameters = 0)\n\n\n\n\n\n\nZend\\Hydrator\\HydratorPluginManagerFactory\n:\n\n\n\n\nno longer implements \nZend\\ServiceManager\\FactoryInterface\n\n\n\n\n__invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null)\n becomes \n__invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Zend\\Hydrator\\HydratorPluginManager\n\n\n\n\n\n\nZend\\Hydrator\\Module\n:\n\n\n\n\ngetConfig()\n becomes \ngetConfig() : array\n\n\n\n\ninit($moduleManager)\n becomes \ninit(Zend\\ModuleManager\\ModuleManager $moduleManager) : void\n\n\n\n\n\n\nZend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy\n:\n\n\n\n\n\n\n__construct(array $strategies, Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null)\n becomes \n__construct(array $strategies, ?Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null)\n\n\n\n\n\n\nZend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter\n:\n\n\n\n\n\n\nfilter($value)\n becomes \nfilter(string $value) : string\n\n\n\n\n\n\nZend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter\n:\n\n\n\n\n\n\nfilter($value)\n becomes \nfilter(string $value) : string\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\ClosureStrategy\n:\n\n\n\n\n\n\n__construct($extractFunc = null, $hydrateFunc = null)\n becomes \n__construct(?callable $extractFunc = null, ?callable $hydrateFunc = null)\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\CollectionStrategy\n:\n\n\n\n\n\n\n__construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName)\n becomes \n__construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName)\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\DateTimeFormatterStrategy\n:\n\n\n\n\n\n\n__construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false)\n becomes \n__construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false)\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\ExplodeStrategy\n:\n\n\n\n\n\n\n__construct($delimiter = ',', $explodeLimit = null)\n becomes \n__construct(string $delimiter = ',', ?int $explodeLimit = null)\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\SerializableStrategy\n:\n\n\n\n\n__construct($serializer, $serializerOptions = null)\n becomes \n__construct($serializer, ?iterable $serializerOptions = null)\n\n\nsetSerializer($serializer)\n becomes \nsetSerializer($serializer) : void\n\n\ngetSerializer()\n becomes \ngetSerializer($serializer) : Zend\\Serializer\\Adapter\\AdapterInterface\n\n\nsetSerializerOptions($serializerOptions)\n becomes \nsetSerializerOptions(iterable $serializerOptions) : void\n\n\n\n\ngetSerializerOptions()\n becomes \ngetSerializerOptions() : array\n\n\n\n\n\n\nZend\\Hydrator\\Strategy\\StrategyChain\n:\n\n\n\n\n__construct($extractionStrategies)\n becomes \n__construct(iterable $extractionStrategies)\n\n\n\n\nArrayMapNamingStrategy and MapNamingStrategy merged\n\n\nArrayMapNamingStrategy\n and \nMapNamingStrategy\n were performing essentially the\nsame duties, but in reverse. As such, for version 3, we have merged the two into\n\nMapNamingStrategy\n. To accommodate the three different use cases, we provide\nthree \"named constructors\":\n\n\npublic static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy;\npublic static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy;\npublic static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy;\n\n\n\nIn the first two cases, the constructor will flip the arrays for purposes of the\nopposite interaction; e.g., using \ncreateFromExtractionMap()\n will create a\nhydration map based on an \narray_flip()\n of the extraction map provided.\n\n\nYou MUST use one of these methods to create an instance,\n as the constructor\nis now marked \nprivate\n.\n\n\nHydratorPluginManager\n\n\nThis version removes support for zend-servicemanager v2 service names. Under\nzend-servicemanager v2, most special characters were removed, and the name\nnormalized to all lowercase. Now, only fully qualified class names are mapped to\nfactories, and short names (names omitting the namespace and/or \"Hydrator\"\nsuffix) are mapped as aliases.\n\n\nAdditionally, version 3 ships a standalone, PSR-11 compliant version,\n\nZend\\Hydrator\\StandaloneHydratorPluginManager\n. By default, the \nHydratorManager\n\nservice alias will point to the \nStandaloneHydratorPluginManager\n if\nzend-servicemanager is not installed, and the \nHydratorPluginManager\n otherwise.\nSee the \nplugin managers chapter\n for more details.",
            "title": "Migration"
        },
        {
            "location": "/v3/migration/#migration-from-version-2",
            "text": "This document details changes made between version 2 and version 3 that could\naffect end-users.",
            "title": "Migration from version 2"
        },
        {
            "location": "/v3/migration/#minimum-supported-versions",
            "text": "",
            "title": "Minimum supported versions"
        },
        {
            "location": "/v3/migration/#php",
            "text": "Version 3 bumps the minimum supported PHP version to version 7.2. We chose this\nversion in particular as it provides the  object  typehint, which allows us to\nenforce at the engine level what we were previously enforcing only at the\ndocumentation level.  Additionally, we have enabled strict types in all class files shipped with this\ncomponent.",
            "title": "PHP"
        },
        {
            "location": "/v3/migration/#zend-eventmanager",
            "text": "The minimum supported version of zend-eventmanager (used by the AggregateHydrator )is now 3.2.1.",
            "title": "zend-eventmanager"
        },
        {
            "location": "/v3/migration/#zend-serializer",
            "text": "The minimum supported version of zend-serializer (used by the SerializableStrategy ) is now 2.9.0.",
            "title": "zend-serializer"
        },
        {
            "location": "/v3/migration/#zend-servicemanager",
            "text": "The minimum supported version of zend-servicemanager (used by the HydratorPluginManager ) is now 3.3.2.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/v3/migration/#renamed-interfaces",
            "text": "The following interfaces were renamed:   Zend\\Hydrator\\FilterEnabledInterface  becomes  Zend\\Hydrator\\Filter\\FilterEnabledInterface .  Zend\\Hydrator\\NamingStrategyEnabledInterface  becomes  Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface .  Zend\\Hydrator\\StrategyEnabledInterface  becomes  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface .",
            "title": "Renamed interfaces"
        },
        {
            "location": "/v3/migration/#renamed-classes",
            "text": "The following classes were renamed:   Zend\\Hydrator\\ArraySerializable  becomes  Zend\\Hydrator\\ArraySerializableHydrator  Zend\\Hydrator\\ClassMethods  becomes  Zend\\Hydrator\\ClassMethodsHydrator  Zend\\Hydrator\\ObjectProperty  becomes  Zend\\Hydrator\\ObjectPropertyHydrator  Zend\\Hydrator\\Reflection  becomes  Zend\\Hydrator\\ReflectionHydrator   In each case, a class named after the original has been created as a deprecated\nextension of the new class. This means you can continue to use the old class\nnames, but only until version 4, at which point they will be removed.  Additionally, aliases for the old class names have been added to the HydratorPluginManager , pointing to services named after the new class names.",
            "title": "Renamed classes"
        },
        {
            "location": "/v3/migration/#interface-changes",
            "text": "Each of the interfaces provided by this package have been updated to add\ntypehints where they were previously omitted (due to engine limitations), both\non parameters and return values. These include:   Zend\\Hydrator\\ExtractionInterface :  extract($object)  becomes  extract(object $object) : array  Zend\\Hydrator\\Filter\\FilterEnabledInterface  (was  Zend\\Hydrator\\FilterEnabledInterface ):  addFilter($name, $filter, $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR)  becomes  addFilter(string $name, $filter, int $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void  hasFilter($name)  becomes  hasFilter(string $name) : bool  removeFilter($name)  becomes  removeFilter(string $name) : void  Zend\\Hydrator\\HydrationInterface :  hydrate(array $data, $object)  becomes  hydrate(array $data, object $object)  Zend\\Hydrator\\HydratorAwareInterface :  setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator)  becomes  setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void  getHydrator()  becomes  getHydrator() : ?Zend\\Hydrator\\HydratorInterface  Zend\\Hydrator\\HydratorAwareTrait  was updated to follow the interface; if\n    you use the trait to implement the interface, no changes will be necessary.  Zend\\Hydrator\\HydratorOptionsInterface :  setOptions($options)  becomes  setOptions(iterable $options) : void  Zend\\Hydrator\\HydratorProviderInterface :  getHydratorConfig()  becomes  getHydratorConfig() : array  Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface  (was  Zend\\Hydrator\\NamingStrategyEnabledInterface ):  setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy)  becomes  setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void  getNamingStrategy()  becomes  getNamingStrategy() : Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface  removeNamingStrategy()  becomes  removeNamingStrategy() : void  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface  (was  Zend\\Hydrator\\StrategyEnabledInterface ):  addStrategy($name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy)  becomes  addStrategy(string $name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) : void  getStrategy($name)  becomes  getStrategy(string $name) : Zend\\Hydrator\\Strategy\\StrategyInterface  hasStrategy($name)  becomes  hasStrategy(string $name) : bool  removeStrategy($name)  becomes  removeStrategy(string $name) : void  Zend\\Hydrator\\Filter\\FilterInterface :  filter($property)  becomes  filter(string $property) : bool  Zend\\Hydrator\\Filter\\FilterProviderInterface :  getFilter()  becomes  getFilter() : Zend\\Hydrator\\Filter\\FilterInterface  Zend\\Hydrator\\Iterator\\HydratingIteratorInterface :  setPrototype($prototype)  becomes  setPrototype($prototype) : void  ( $prototype  continues to allow either a  string  or object)  setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator)  becomes  setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void  Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface :  extract($name)  becomes  extract(string $name, ?object $object = null) : string  hydrate($name)  becomes  hydrate(string $name, ?array $data = null) : string  Zend\\Hydrator\\Strategy\\StrategyInterface :  hydrate($value)  becomes  hydrate($value, ?array $data = null)  (the  $value  parameter and return value can be any PHP type)  extract($value)  becomes  extract($value, ?object $object = null)  (the  $value  parameter and return value can be any PHP type)   All implementations of these interface shipped in the component have been\nupdated to ensure signatures match.  If you are providing custom implementations, or extending the implementations\nprovided in this package, you may need to update signatures per the above.",
            "title": "Interface changes"
        },
        {
            "location": "/v3/migration/#typehints",
            "text": "As noted in the above section, typehints were added to all interfaces. In\naddition to those changes, the following methods were also updated to add\ntypehints:   Zend\\Hydrator\\Aggregate\\AggregateHydrator :   add(Zend\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY)  becomes  add(Zend\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void    Zend\\Hydrator\\Aggregate\\ExtractEvent :   __construct($target, $extractionObject)  becomes  __construct(object $target, object $extractionObject)  getExtractionObject()  becomes  getExtractionObject() : object  setExtractionObject($extractionObject)  becomes  setExtractionObject(object $extractionObject) : void  getExtractedData()  becomes  getExtractedData() : array  setExtractedData(array $extractedData)  becomes  setExtractedData(array $extractedData) : void   mergeExtractedData(array $additionalData)  becomes  mergeExtractedData(array $additionalData) : void    Zend\\Hydrator\\Aggregate\\HydrateEvent :   __construct($target, $hydratedObject, array $hydrationData)  becomes  __construct(object $target, object $hydratedObject, array $hydrationData)  getHydratedObject()  becomes  getHydratedObject() : object  setHydratedObject($hydratedObject)  becomes  setHydratedObject(object $hydratedObject) : void  getHydrationData()  becomes  getHydrationData() : array   setHydrationData(array $hydrationData)  becomes  setHydrationData(array $hydrationData) : void    Zend\\Hydrator\\Aggregate\\HydratorListener :   onHydrate(HydrateEvent $event)  becomes  onHydrate(HydrateEvent $event) : object   onExtract(ExtractEvent $event)  becomes  onExtract(ExtractEvent $event) : array    Zend\\Hydrator\\ClassMethodsHydrator  (was  Zend\\Hydrator\\ClassMethods ):   __construct($underscoreSeparatedKeys = true, $methodExistsCheck = false)  becomes  __construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false)  setUnderscoreSeparatedKeys($underscoreSeparatedKeys)  becomes  setUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void  getUnderscoreSeparatedKeys()  becomes  getUnderscoreSeparatedKeys() : bool  setMethodExistsCheck($methodExistsCheck)  becomes  setMethodExistsCheck(bool $methodExistsCheck) : void   getMethodExistsCheck()  becomes  getMethodExistsCheck() : bool    Zend\\Hydrator\\ConfigProvider :   __invoke()  becomes  __invoke() : array   getDependencyConfig()  becomes  getDependencyConfig() : array    Zend\\Hydrator\\DelegatingHydratorFactory :   no longer implements  Zend\\ServiceManager\\FactoryInterface   __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null)  becomes  __invoke(Psr\\Container\\ContainerInterface $container) : Zend\\Hydrator\\DelegatingHydrator    Zend\\Hydrator\\Filter\\FilterComposite :    __construct($orFilters = [], $andFilters = [])  becomes  __construct(array $orFilters = [], array $andFilters = [])    Zend\\Hydrator\\Filter\\MethodMatchFilter :    __construct($method, $exclude = true)  becomes  __construct(string $method, bool $exclude = true)    Zend\\Hydrator\\Filter\\NumberOfParameterFilter :    __construct($numberOfParameters = 0)  becomes  __construct(int $numberOfParameters = 0)    Zend\\Hydrator\\HydratorPluginManagerFactory :   no longer implements  Zend\\ServiceManager\\FactoryInterface   __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null)  becomes  __invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Zend\\Hydrator\\HydratorPluginManager    Zend\\Hydrator\\Module :   getConfig()  becomes  getConfig() : array   init($moduleManager)  becomes  init(Zend\\ModuleManager\\ModuleManager $moduleManager) : void    Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy :    __construct(array $strategies, Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null)  becomes  __construct(array $strategies, ?Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null)    Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter :    filter($value)  becomes  filter(string $value) : string    Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter :    filter($value)  becomes  filter(string $value) : string    Zend\\Hydrator\\Strategy\\ClosureStrategy :    __construct($extractFunc = null, $hydrateFunc = null)  becomes  __construct(?callable $extractFunc = null, ?callable $hydrateFunc = null)    Zend\\Hydrator\\Strategy\\CollectionStrategy :    __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName)  becomes  __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName)    Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy :    __construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false)  becomes  __construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false)    Zend\\Hydrator\\Strategy\\ExplodeStrategy :    __construct($delimiter = ',', $explodeLimit = null)  becomes  __construct(string $delimiter = ',', ?int $explodeLimit = null)    Zend\\Hydrator\\Strategy\\SerializableStrategy :   __construct($serializer, $serializerOptions = null)  becomes  __construct($serializer, ?iterable $serializerOptions = null)  setSerializer($serializer)  becomes  setSerializer($serializer) : void  getSerializer()  becomes  getSerializer($serializer) : Zend\\Serializer\\Adapter\\AdapterInterface  setSerializerOptions($serializerOptions)  becomes  setSerializerOptions(iterable $serializerOptions) : void   getSerializerOptions()  becomes  getSerializerOptions() : array    Zend\\Hydrator\\Strategy\\StrategyChain :   __construct($extractionStrategies)  becomes  __construct(iterable $extractionStrategies)",
            "title": "Typehints"
        },
        {
            "location": "/v3/migration/#arraymapnamingstrategy-and-mapnamingstrategy-merged",
            "text": "ArrayMapNamingStrategy  and  MapNamingStrategy  were performing essentially the\nsame duties, but in reverse. As such, for version 3, we have merged the two into MapNamingStrategy . To accommodate the three different use cases, we provide\nthree \"named constructors\":  public static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy;\npublic static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy;\npublic static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy;  In the first two cases, the constructor will flip the arrays for purposes of the\nopposite interaction; e.g., using  createFromExtractionMap()  will create a\nhydration map based on an  array_flip()  of the extraction map provided.  You MUST use one of these methods to create an instance,  as the constructor\nis now marked  private .",
            "title": "ArrayMapNamingStrategy and MapNamingStrategy merged"
        },
        {
            "location": "/v3/migration/#hydratorpluginmanager",
            "text": "This version removes support for zend-servicemanager v2 service names. Under\nzend-servicemanager v2, most special characters were removed, and the name\nnormalized to all lowercase. Now, only fully qualified class names are mapped to\nfactories, and short names (names omitting the namespace and/or \"Hydrator\"\nsuffix) are mapped as aliases.  Additionally, version 3 ships a standalone, PSR-11 compliant version, Zend\\Hydrator\\StandaloneHydratorPluginManager . By default, the  HydratorManager \nservice alias will point to the  StandaloneHydratorPluginManager  if\nzend-servicemanager is not installed, and the  HydratorPluginManager  otherwise.\nSee the  plugin managers chapter  for more details.",
            "title": "HydratorPluginManager"
        },
        {
            "location": "/v2/quick-start/",
            "text": "zend-hydrator\n\n\nHydration is the act of populating an object from a set of data.\n\n\nzend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.\n\n\nThe component consists of interfaces, and several implementations for common use cases.\n\n\nBase Interfaces\n\n\nExtractionInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /\n     * Extract values from an object\n     *\n     * @param  object $object\n     * @return array\n     */\n    public function extract($object);\n}\n\n\n\nHydrationInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /\n     * Hydrate $object with the provided $data.\n     *\n     * @param  array $data\n     * @param  object $object\n     * @return object\n     */\n    public function hydrate(array $data, $object);\n}\n\n\n\nHydratorInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}\n\n\n\nUsage\n\n\nUsage involves instantiating the hydrator, and then passing information to it.\n\n\nuse Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializable();\n\n// To hydrate an object from values in an array:\n$object = $hydrator->hydrate($data, new ArrayObject());\n\n// or, going the other way and extracting the values from an object as an array:\n$data = $hydrator->extract($object);\n\n\n\nAvailable Implementations\n\n\nZend\\Hydrator\\ArraySerializable\n\n\nFollows the definition of \nArrayObject\n. Objects must implement either the \nexchangeArray()\n or\n\npopulate()\n methods to support hydration, and the \ngetArrayCopy()\n method to support extraction.\n\n\nZend\\Hydrator\\ClassMethods\n\n\nAny data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction.\n\n\nZend\\Hydrator\\DelegatingHydrator\n\n\nComposes a hydrator locator, and will delegate \nhydrate()\n and \nextract()\n calls\nto the appropriate one based upon the class name of the object being operated\non.\n\n\n// Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethods;\n$artistHydrator = new Zend\\Hydrator\\ClassMethods;\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object\n$array = $delegating->extract(new Artist);\n$artist = $delegating->hydrate($data, new Artist);\n\n\n\nZend\\Hydrator\\ObjectProperty\n\n\nAny data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.\n\n\nZend\\Hydrator\\Reflection\n\n\nSimilar to the \nObjectProperty\n hydrator, but uses \nPHP's reflection API\n\nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Quick Start"
        },
        {
            "location": "/v2/quick-start/#zend-hydrator",
            "text": "Hydration is the act of populating an object from a set of data.  zend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.  The component consists of interfaces, and several implementations for common use cases.",
            "title": "zend-hydrator"
        },
        {
            "location": "/v2/quick-start/#base-interfaces",
            "text": "",
            "title": "Base Interfaces"
        },
        {
            "location": "/v2/quick-start/#extractioninterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /\n     * Extract values from an object\n     *\n     * @param  object $object\n     * @return array\n     */\n    public function extract($object);\n}",
            "title": "ExtractionInterface"
        },
        {
            "location": "/v2/quick-start/#hydrationinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /\n     * Hydrate $object with the provided $data.\n     *\n     * @param  array $data\n     * @param  object $object\n     * @return object\n     */\n    public function hydrate(array $data, $object);\n}",
            "title": "HydrationInterface"
        },
        {
            "location": "/v2/quick-start/#hydratorinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}",
            "title": "HydratorInterface"
        },
        {
            "location": "/v2/quick-start/#usage",
            "text": "Usage involves instantiating the hydrator, and then passing information to it.  use Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializable();\n\n// To hydrate an object from values in an array:\n$object = $hydrator->hydrate($data, new ArrayObject());\n\n// or, going the other way and extracting the values from an object as an array:\n$data = $hydrator->extract($object);",
            "title": "Usage"
        },
        {
            "location": "/v2/quick-start/#available-implementations",
            "text": "",
            "title": "Available Implementations"
        },
        {
            "location": "/v2/quick-start/#zend92hydrator92arrayserializable",
            "text": "Follows the definition of  ArrayObject . Objects must implement either the  exchangeArray()  or populate()  methods to support hydration, and the  getArrayCopy()  method to support extraction.",
            "title": "Zend\\Hydrator\\ArraySerializable"
        },
        {
            "location": "/v2/quick-start/#zend92hydrator92classmethods",
            "text": "Any data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction.",
            "title": "Zend\\Hydrator\\ClassMethods"
        },
        {
            "location": "/v2/quick-start/#zend92hydrator92delegatinghydrator",
            "text": "Composes a hydrator locator, and will delegate  hydrate()  and  extract()  calls\nto the appropriate one based upon the class name of the object being operated\non.  // Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethods;\n$artistHydrator = new Zend\\Hydrator\\ClassMethods;\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object\n$array = $delegating->extract(new Artist);\n$artist = $delegating->hydrate($data, new Artist);",
            "title": "Zend\\Hydrator\\DelegatingHydrator"
        },
        {
            "location": "/v2/quick-start/#zend92hydrator92objectproperty",
            "text": "Any data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.",
            "title": "Zend\\Hydrator\\ObjectProperty"
        },
        {
            "location": "/v2/quick-start/#zend92hydrator92reflection",
            "text": "Similar to the  ObjectProperty  hydrator, but uses  PHP's reflection API \nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Zend\\Hydrator\\Reflection"
        },
        {
            "location": "/v2/filter/",
            "text": "Zend\\Hydrator\\Filter\n\n\nHydrator filters allow you to manipulate the behavior of the \nextract()\n\noperation.  This is especially useful, if you want to omit some internals (e.g.\n\ngetServiceManager()\n) from the array representation.\n\n\nIt comes with a helpful \nComposite\n implementation, and several filters for\ncommon use cases. The filters are composed in the \nAbstractHydrator\n, so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter\n     * does not match\n     *\n     * @param string $property The name of the property\n     * @return bool\n     */\n    public function filter($property);\n}\n\n\n\nIf it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.\n\n\nFilter implementations\n\n\nZend\\Hydrator\\Filter\\GetFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which getters will\nbe extracted. It checks if the key to extract starts with \nget\n or the object\ncontains a method beginning with \nget\n (e.g., \nZend\\Foo\\Bar::getFoo\n).\n\n\nZend\\Hydrator\\Filter\\HasFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which \nhas\n methods\nwill be extracted. It checks if the key to extract begins with \nhas\n or the\nobject contains a method beginning with \nhas\n (e.g., \nZend\\Foo\\Bar::hasFoo\n).\n\n\nZend\\Hydrator\\Filter\\IsFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which \nis\n methods\nwill be extracted. It checks if the key to extract begins with \nis\n or the\nobject contains a method beginning with \nis\n (e.g., \nZend\\Foo\\Bar::isFoo\n).\n\n\nZend\\Hydrator\\Filter\\MethodMatchFilter\n\n\nThis filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass \nfalse\n to change\nthe behavior.\n\n\nZend\\Hydrator\\Filter\\NumberOfParameterFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to check the number of\nparameters. By convention, the \nget\n, \nhas\n and \nis\n methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.\n\n\nRemove filters\n\n\nIf you want to tell e.g. the \nClassMethods\n hydrator, to not extract methods that start with \nis\n,\nremove the related filter:\n\n\n$hydrator = new ClassMethods(false);\n$hydrator->removeFilter('is');\n\n\n\nAfter performing the above, the key/value pairs for \nis\n methods will not end up\nin your extracted array anymore. The filters can be used in any hydrator, but\nthe \nClassMethods\n hydrator is the only one, that has pre-registered filters:\n\n\n$this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);\n\n\n\nIf these are not appropriate for your object, you can unregister them as shown\nin the previous example.\n\n\nAdd filters\n\n\nYou can add filters to any hydrator that extends the \nAbstractHydrator\n. Filters\ncan either implement \nFilterInterface\n, or simply be PHP callables:\n\n\n$hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n});\n\n\n\nBy default, every filter you add will be added with a conditional \nor\n. If you\nwant to add it with \nand\n (as the \nNumberOfParameterFilter\n that is added to the\n\nClassMethods\n hydrator by default), provide the conditon as the third argument\nto \naddFilter\n:\n\n\n$hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n}, FilterComposite::CONDITION_AND);\n\n\n\nOne common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:\n\n\n$hydrator->addFilter(\n  'servicemanager',\n  new MethodMatchFilter('getServiceManager'),\n  FilterComposite::CONDITION_AND\n);\n\n\n\nThe example above will exclude the \ngetServiceManager()\n method and the\n\nservicemanager\n key from extraction, even if the \nget\n filter wants to add it.\n\n\nUse FilterComposite for complex filters\n\n\nFilterComposite\n implements \nFilterInterface\n as well, so you can add it as\na regular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent composites with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR\n\n\nAt the given level of the composite, at least one filter in that condition block\nhas to return true to extract the value.\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND\n\n\nAt the given level of the composite, all filters in that condition block must\nreturn true to extract the value.\n\n\nFilterComposite Examples\n\n\nThis composition will have a similar logic as the if below:\n\n\n$composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);\n\n// This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    //do extraction\n}\n\n\n\nIf you only have one condition (e.g., only an \nand\n or \nor\n) block, the other\none will be completely ignored.\n\n\nA bit more complex filter can look like this:\n\n\n$composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the hydrator\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}\n\n\n\nIf you perform this on the \nClassMethods\n hydrator, all getters will get\nextracted, except for \ngetServiceManager()\n and \ngetEventManager()\n.\n\n\nUsing the provider interface\n\n\nFilterProviderInterface\n allows you to configure the behavior of the hydrator\ninside your objects.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}\n\n\n\n(The \ngetFilter()\n method is automatically excluded from \nextract()\n.) If the\nextracted object implements the \nZend\\Hydrator\\Filter\\FilterProviderInterface\n,\nthe returned \nFilterInterface\n instance can also be a \nFilterComposite\n.\n\n\nFor example:\n\n\nClass Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethods(false);\n$extractedArray = $hydrator->extract(new Foo());\n\n\n\n$extractedArray\n will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.\n\n\n\n\nNote\n\n\nAll pre-registered filters from the \nClassMethods\n hydrator are ignored when\nthis interface is used.",
            "title": "Filters"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter",
            "text": "Hydrator filters allow you to manipulate the behavior of the  extract() \noperation.  This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation.  It comes with a helpful  Composite  implementation, and several filters for\ncommon use cases. The filters are composed in the  AbstractHydrator , so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter\n     * does not match\n     *\n     * @param string $property The name of the property\n     * @return bool\n     */\n    public function filter($property);\n}  If it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.",
            "title": "Zend\\Hydrator\\Filter"
        },
        {
            "location": "/v2/filter/#filter-implementations",
            "text": "",
            "title": "Filter implementations"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92getfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which getters will\nbe extracted. It checks if the key to extract starts with  get  or the object\ncontains a method beginning with  get  (e.g.,  Zend\\Foo\\Bar::getFoo ).",
            "title": "Zend\\Hydrator\\Filter\\GetFilter"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92hasfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which  has  methods\nwill be extracted. It checks if the key to extract begins with  has  or the\nobject contains a method beginning with  has  (e.g.,  Zend\\Foo\\Bar::hasFoo ).",
            "title": "Zend\\Hydrator\\Filter\\HasFilter"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92isfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which  is  methods\nwill be extracted. It checks if the key to extract begins with  is  or the\nobject contains a method beginning with  is  (e.g.,  Zend\\Foo\\Bar::isFoo ).",
            "title": "Zend\\Hydrator\\Filter\\IsFilter"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92methodmatchfilter",
            "text": "This filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass  false  to change\nthe behavior.",
            "title": "Zend\\Hydrator\\Filter\\MethodMatchFilter"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92numberofparameterfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to check the number of\nparameters. By convention, the  get ,  has  and  is  methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.",
            "title": "Zend\\Hydrator\\Filter\\NumberOfParameterFilter"
        },
        {
            "location": "/v2/filter/#remove-filters",
            "text": "If you want to tell e.g. the  ClassMethods  hydrator, to not extract methods that start with  is ,\nremove the related filter:  $hydrator = new ClassMethods(false);\n$hydrator->removeFilter('is');  After performing the above, the key/value pairs for  is  methods will not end up\nin your extracted array anymore. The filters can be used in any hydrator, but\nthe  ClassMethods  hydrator is the only one, that has pre-registered filters:  $this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);  If these are not appropriate for your object, you can unregister them as shown\nin the previous example.",
            "title": "Remove filters"
        },
        {
            "location": "/v2/filter/#add-filters",
            "text": "You can add filters to any hydrator that extends the  AbstractHydrator . Filters\ncan either implement  FilterInterface , or simply be PHP callables:  $hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n});  By default, every filter you add will be added with a conditional  or . If you\nwant to add it with  and  (as the  NumberOfParameterFilter  that is added to the ClassMethods  hydrator by default), provide the conditon as the third argument\nto  addFilter :  $hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n}, FilterComposite::CONDITION_AND);  One common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:  $hydrator->addFilter(\n  'servicemanager',\n  new MethodMatchFilter('getServiceManager'),\n  FilterComposite::CONDITION_AND\n);  The example above will exclude the  getServiceManager()  method and the servicemanager  key from extraction, even if the  get  filter wants to add it.",
            "title": "Add filters"
        },
        {
            "location": "/v2/filter/#use-filtercomposite-for-complex-filters",
            "text": "FilterComposite  implements  FilterInterface  as well, so you can add it as\na regular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent composites with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:",
            "title": "Use FilterComposite for complex filters"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92filtercompositecondition95or",
            "text": "At the given level of the composite, at least one filter in that condition block\nhas to return true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR"
        },
        {
            "location": "/v2/filter/#zend92hydrator92filter92filtercompositecondition95and",
            "text": "At the given level of the composite, all filters in that condition block must\nreturn true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND"
        },
        {
            "location": "/v2/filter/#filtercomposite-examples",
            "text": "This composition will have a similar logic as the if below:  $composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);\n\n// This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    //do extraction\n}  If you only have one condition (e.g., only an  and  or  or ) block, the other\none will be completely ignored.  A bit more complex filter can look like this:  $composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the hydrator\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}  If you perform this on the  ClassMethods  hydrator, all getters will get\nextracted, except for  getServiceManager()  and  getEventManager() .",
            "title": "FilterComposite Examples"
        },
        {
            "location": "/v2/filter/#using-the-provider-interface",
            "text": "FilterProviderInterface  allows you to configure the behavior of the hydrator\ninside your objects.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}  (The  getFilter()  method is automatically excluded from  extract() .) If the\nextracted object implements the  Zend\\Hydrator\\Filter\\FilterProviderInterface ,\nthe returned  FilterInterface  instance can also be a  FilterComposite .  For example:  Class Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethods(false);\n$extractedArray = $hydrator->extract(new Foo());  $extractedArray  will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.",
            "title": "Using the provider interface"
        },
        {
            "location": "/v2/filter/#note",
            "text": "All pre-registered filters from the  ClassMethods  hydrator are ignored when\nthis interface is used.",
            "title": "Note"
        },
        {
            "location": "/v2/strategy/",
            "text": "Zend\\Hydrator\\Strategy\n\n\nYou can add \nZend\\Hydrator\\Strategy\\StrategyInterface\n to any of the hydrators\n(except if it extends \nZend\\Hydrator\\AbstractHydrator\n or implements\n\nZend\\Hydrator\\HydratorInterface\n and \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n)\nto manipulate the way how they behave on \nextract()\n and \nhydrate()\n for\nspecific key / value pairs. This is the interface that needs to be implemented:\n\n\nnamespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n     /**\n      * Converts the given value so that it can be extracted by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be extracted.\n      */\n     public function extract($value);\n\n     /**\n      * Converts the given value so that it can be hydrated by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be hydrated.\n      */\n     public function hydrate($value);\n}\n\n\n\nThis interface is similar to \nZend\\Hydrator\\HydratorInterface\n; the reason\nis that strategies provide a proxy implementation for \nhydrate()\n and \nextract()\n.\n\n\nAdding strategies to the hydrators\n\n\nTo allow strategies within your hydrator, \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n\nprovides the following methods:\n\n\nnamespace Zend\\Hydrator;\n\nuse Zend\\Hydrator\\Strategy\\StrategyInterface;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     *\n     * @param string $name The name of the strategy to register.\n     * @param StrategyInterface $strategy The strategy to register.\n     * @return HydratorInterface\n     */\n    public function addStrategy($name, StrategyInterface $strategy);\n\n    /**\n     * Gets the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to get.\n     * @return StrategyInterface\n     */\n    public function getStrategy($name);\n\n    /**\n     * Checks if the strategy with the given name exists.\n     *\n     * @param string $name The name of the strategy to check for.\n     * @return bool\n     */\n    public function hasStrategy($name);\n\n    /**\n     * Removes the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to remove.\n     * @return HydratorInterface\n     */\n    public function removeStrategy($name);\n}\n\n\n\nEvery hydrator shipped by default provides this functionality;\n\nAbstractHydrator\n fully implements it as well. As such, if you want to use this\nfunctionality in your own hydrators, you should extend \nAbstractHydrator\n.\n\n\nAvailable implementations\n\n\nZend\\Hydrator\\Strategy\\BooleanStrategy\n\n\nThis strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for \ntrue\n and\n\nfalse\n.\n\n\nZend\\Hydrator\\Strategy\\ClosureStrategy\n\n\nThis is a strategy that allows you to pass in options for:\n\n\n\n\nhydrate\n, a callback to be called when hydrating a value, and\n\n\nextract\n, a callback to be called when extracting a value.\n\n\n\n\nZend\\Hydrator\\Strategy\\DateTimeFormatterStrategy\n\n\nDateTimeFormatterStrategy\n provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.\n\n\nAs of version 2.4.1, this strategy now allows \nDateTime\n formats that use \n!\n to\nprepend the format, or \n|\n or \n+\n to append it; these ensure that, during\nhydration, the new \nDateTime\n instance created will set the time element\naccordingly. As a specific example, \nY-m-d|\n will drop the time component,\nensuring comparisons are based on a midnight time value.\n\n\nZend\\Hydrator\\Strategy\\DefaultStrategy\n\n\nThe \nDefaultStrategy\n simply proxies everything through, without performing any\nconversion of values.\n\n\nZend\\Hydrator\\Strategy\\ExplodeStrategy\n\n\nThis strategy is a wrapper around PHP's \nimplode()\n and \nexplode()\n functions.\nThe delimiter and a limit can be provided to the constructor; the limit will\nonly be used for \nextract\n operations.\n\n\nZend\\Hydrator\\Strategy\\SerializableStrategy\n\n\nSerializableStrategy\n provides the functionality backing\n\nZend\\Hydrator\\ArraySerializable\n. You can use it with custom implementations\nfor \nZend\\Serializer\\Adapter\\AdapterInterface\n if you want to as well.\n\n\nZend\\Hydrator\\Strategy\\StrategyChain\n\n\nThis strategy takes an array of \nStrategyInterface\n instances and iterates\nover them when performing \nextract()\n and \nhydrate()\n operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.\n\n\nWriting custom strategies\n\n\nThe following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing \nstr_rot13()\n during both the \nextract()\n and \nhydrate()\n operations:\n\n\nclass Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}\n\n\n\nThis is the example class with which we want to use the hydrator example:\n\n\nclass Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}\n\n\n\nNow, we'll add the \nrot13\n strategy to the method \ngetFoo()\n and \nsetFoo($foo)\n:\n\n\n$foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethods();\n$hydrator->addStrategy('foo', new Rot13Strategy());\n\n\n\nWhen you use the hydrator to extract an array for the object \n$foo\n, you'll\nreceive the following:\n\n\n$extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }\n\n\n\nAnd when hydrating a new \nFoo\n instance:\n\n\n$hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Strategies"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy",
            "text": "You can add  Zend\\Hydrator\\Strategy\\StrategyInterface  to any of the hydrators\n(except if it extends  Zend\\Hydrator\\AbstractHydrator  or implements Zend\\Hydrator\\HydratorInterface  and  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface )\nto manipulate the way how they behave on  extract()  and  hydrate()  for\nspecific key / value pairs. This is the interface that needs to be implemented:  namespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n     /**\n      * Converts the given value so that it can be extracted by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be extracted.\n      */\n     public function extract($value);\n\n     /**\n      * Converts the given value so that it can be hydrated by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be hydrated.\n      */\n     public function hydrate($value);\n}  This interface is similar to  Zend\\Hydrator\\HydratorInterface ; the reason\nis that strategies provide a proxy implementation for  hydrate()  and  extract() .",
            "title": "Zend\\Hydrator\\Strategy"
        },
        {
            "location": "/v2/strategy/#adding-strategies-to-the-hydrators",
            "text": "To allow strategies within your hydrator,  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface \nprovides the following methods:  namespace Zend\\Hydrator;\n\nuse Zend\\Hydrator\\Strategy\\StrategyInterface;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     *\n     * @param string $name The name of the strategy to register.\n     * @param StrategyInterface $strategy The strategy to register.\n     * @return HydratorInterface\n     */\n    public function addStrategy($name, StrategyInterface $strategy);\n\n    /**\n     * Gets the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to get.\n     * @return StrategyInterface\n     */\n    public function getStrategy($name);\n\n    /**\n     * Checks if the strategy with the given name exists.\n     *\n     * @param string $name The name of the strategy to check for.\n     * @return bool\n     */\n    public function hasStrategy($name);\n\n    /**\n     * Removes the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to remove.\n     * @return HydratorInterface\n     */\n    public function removeStrategy($name);\n}  Every hydrator shipped by default provides this functionality; AbstractHydrator  fully implements it as well. As such, if you want to use this\nfunctionality in your own hydrators, you should extend  AbstractHydrator .",
            "title": "Adding strategies to the hydrators"
        },
        {
            "location": "/v2/strategy/#available-implementations",
            "text": "",
            "title": "Available implementations"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92booleanstrategy",
            "text": "This strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for  true  and false .",
            "title": "Zend\\Hydrator\\Strategy\\BooleanStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92closurestrategy",
            "text": "This is a strategy that allows you to pass in options for:   hydrate , a callback to be called when hydrating a value, and  extract , a callback to be called when extracting a value.",
            "title": "Zend\\Hydrator\\Strategy\\ClosureStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92datetimeformatterstrategy",
            "text": "DateTimeFormatterStrategy  provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.  As of version 2.4.1, this strategy now allows  DateTime  formats that use  !  to\nprepend the format, or  |  or  +  to append it; these ensure that, during\nhydration, the new  DateTime  instance created will set the time element\naccordingly. As a specific example,  Y-m-d|  will drop the time component,\nensuring comparisons are based on a midnight time value.",
            "title": "Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92defaultstrategy",
            "text": "The  DefaultStrategy  simply proxies everything through, without performing any\nconversion of values.",
            "title": "Zend\\Hydrator\\Strategy\\DefaultStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92explodestrategy",
            "text": "This strategy is a wrapper around PHP's  implode()  and  explode()  functions.\nThe delimiter and a limit can be provided to the constructor; the limit will\nonly be used for  extract  operations.",
            "title": "Zend\\Hydrator\\Strategy\\ExplodeStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92serializablestrategy",
            "text": "SerializableStrategy  provides the functionality backing Zend\\Hydrator\\ArraySerializable . You can use it with custom implementations\nfor  Zend\\Serializer\\Adapter\\AdapterInterface  if you want to as well.",
            "title": "Zend\\Hydrator\\Strategy\\SerializableStrategy"
        },
        {
            "location": "/v2/strategy/#zend92hydrator92strategy92strategychain",
            "text": "This strategy takes an array of  StrategyInterface  instances and iterates\nover them when performing  extract()  and  hydrate()  operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.",
            "title": "Zend\\Hydrator\\Strategy\\StrategyChain"
        },
        {
            "location": "/v2/strategy/#writing-custom-strategies",
            "text": "The following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing  str_rot13()  during both the  extract()  and  hydrate()  operations:  class Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}  This is the example class with which we want to use the hydrator example:  class Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}  Now, we'll add the  rot13  strategy to the method  getFoo()  and  setFoo($foo) :  $foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethods();\n$hydrator->addStrategy('foo', new Rot13Strategy());  When you use the hydrator to extract an array for the object  $foo , you'll\nreceive the following:  $extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }  And when hydrating a new  Foo  instance:  $hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Writing custom strategies"
        },
        {
            "location": "/v2/aggregate/",
            "text": "AggregateHydrator\n\n\nZend\\Hydrator\\Aggregate\\AggregateHydrator\n is an implementation of\n\nZend\\Hydrator\\HydratorInterface\n that composes multiple hydrators via event listeners.\n\n\nYou typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.\n\n\nInstallation requirements\n\n\nThe \nAggregateHydrator\n depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:\n\n\n$ composer require zendframework/zend-eventmanager\n\n\n\nBasic usage\n\n\nA simple use case may be hydrating a \nBlogPost\n object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);\n\n\n\n\n\nHydrator priorities\n\n\nAggregateHydrator::add\n has a second optional argument, \n$priority\n. If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.\n\n\n\n\nIn order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:\n\n\nnamespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}\n\n\n\nAdvanced use cases\n\n\nSince the \nAggregateHydrator\n is event-driven, you can use the \nEventManager\n\nAPI to tweak its behaviour.\n\n\nCommon use cases include:\n\n\n\n\nRemoval of hydrated data keys (passwords/confidential information) depending\n  on business rules.\n\n\nCaching of the hydration/extraction process.\n\n\nTransformations on extracted data, for compatibility with third-party APIs.\n\n\n\n\nIn the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);\n\n\n\nWith an aggregate hydrator configured in this way, any\n\n$hydrator->extract($blogPost)\n operation will be cached.",
            "title": "Aggregates"
        },
        {
            "location": "/v2/aggregate/#aggregatehydrator",
            "text": "Zend\\Hydrator\\Aggregate\\AggregateHydrator  is an implementation of Zend\\Hydrator\\HydratorInterface  that composes multiple hydrators via event listeners.  You typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.",
            "title": "AggregateHydrator"
        },
        {
            "location": "/v2/aggregate/#installation-requirements",
            "text": "The  AggregateHydrator  depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:  $ composer require zendframework/zend-eventmanager",
            "title": "Installation requirements"
        },
        {
            "location": "/v2/aggregate/#basic-usage",
            "text": "A simple use case may be hydrating a  BlogPost  object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);",
            "title": "Basic usage"
        },
        {
            "location": "/v2/aggregate/#hydrator-priorities",
            "text": "AggregateHydrator::add  has a second optional argument,  $priority . If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.   In order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:  namespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}",
            "title": "Hydrator priorities"
        },
        {
            "location": "/v2/aggregate/#advanced-use-cases",
            "text": "Since the  AggregateHydrator  is event-driven, you can use the  EventManager \nAPI to tweak its behaviour.  Common use cases include:   Removal of hydrated data keys (passwords/confidential information) depending\n  on business rules.  Caching of the hydration/extraction process.  Transformations on extracted data, for compatibility with third-party APIs.   In the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);  With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost)  operation will be cached.",
            "title": "Advanced use cases"
        },
        {
            "location": "/v2/naming-strategy/identity-naming-strategy/",
            "text": "IdentityNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy\n uses the keys provided to\nit for hydration and extraction.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar\n\n\n\nThis strategy can be used in hydrators as well:\n\n\nclass Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Identity"
        },
        {
            "location": "/v2/naming-strategy/identity-naming-strategy/#identitynamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy  uses the keys provided to\nit for hydration and extraction.",
            "title": "IdentityNamingStrategy"
        },
        {
            "location": "/v2/naming-strategy/identity-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar  This strategy can be used in hydrators as well:  class Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v2/naming-strategy/map-naming-strategy/",
            "text": "MapNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\MapNamingStrategy\n allows you to provide a map of\nkeys to use when hydrating and extracting; the map will translate the key based\non the direction.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array(\n    'foo' => 'bar',\n    'baz' => 'bash'\n));\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash\n\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz\n\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped:\n\n\nclass Foo\n{\n    public $bar;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar',\n    'baz' => 'bash'\n]);\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Mapping"
        },
        {
            "location": "/v2/naming-strategy/map-naming-strategy/#mapnamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy  allows you to provide a map of\nkeys to use when hydrating and extracting; the map will translate the key based\non the direction.",
            "title": "MapNamingStrategy"
        },
        {
            "location": "/v2/naming-strategy/map-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array(\n    'foo' => 'bar',\n    'baz' => 'bash'\n));\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash\n\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz  This strategy can be used in hydrators to dictate how keys should be mapped:  class Foo\n{\n    public $bar;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar',\n    'baz' => 'bash'\n]);\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v2/naming-strategy/underscore-naming-strategy/",
            "text": "UnderscoreNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\n converts snake case strings (e.g.\n\nfoo_bar_baz\n) to camel-case strings (e.g. \nfooBarBaz\n) and vice versa.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar\n\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped.\n\n\nclass Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Underscore Mapping"
        },
        {
            "location": "/v2/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy  converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g.  fooBarBaz ) and vice versa.",
            "title": "UnderscoreNamingStrategy"
        },
        {
            "location": "/v2/naming-strategy/underscore-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar  This strategy can be used in hydrators to dictate how keys should be mapped.  class Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/v2/naming-strategy/composite-naming-strategy/",
            "text": "CompositeNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy\n allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.\n\n\nBasic Usage\n\n\nWhen invoked, the following composite strategy will extract the property \nbar\n\nto the array key \nfoo\n (using the \nMapNamingStrategy\n), and the property\n\nbarBat\n to the array key \nbar_bat\n (using the \nUnderscoreNamingStrategy\n):\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n\n\nUnfortunately, the \nCompositeNamingStrategy\n can only be used for extraction as it will not know how\nto handle the keys necessary for hydration (\nfoo\n and \nbar_bat\n, respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Composite"
        },
        {
            "location": "/v2/naming-strategy/composite-naming-strategy/#compositenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy  allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.",
            "title": "CompositeNamingStrategy"
        },
        {
            "location": "/v2/naming-strategy/composite-naming-strategy/#basic-usage",
            "text": "When invoked, the following composite strategy will extract the property  bar \nto the array key  foo  (using the  MapNamingStrategy ), and the property barBat  to the array key  bar_bat  (using the  UnderscoreNamingStrategy ):  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 )  Unfortunately, the  CompositeNamingStrategy  can only be used for extraction as it will not know how\nto handle the keys necessary for hydration ( foo  and  bar_bat , respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 )\n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Basic Usage"
        },
        {
            "location": "/quick-start/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/quick-start/';\n  });",
            "title": "_quick_start"
        },
        {
            "location": "/filter/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/filter/';\n  });",
            "title": "_filters"
        },
        {
            "location": "/strategy/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/strategy/';\n  });",
            "title": "_strategies"
        },
        {
            "location": "/aggregate/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/aggregate/';\n  });",
            "title": "_aggregates"
        },
        {
            "location": "/naming-strategy/identity-naming-strategy/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/naming-strategy/identity-naming-strategy/';\n  });",
            "title": "_naming_strategies-identity"
        },
        {
            "location": "/naming-strategy/map-naming-strategy/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/naming-strategy/map-naming-strategy/';\n  });",
            "title": "_naming_strategies-mapping"
        },
        {
            "location": "/naming-strategy/underscore-naming-strategy/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/naming-strategy/underscore-naming-strategy/';\n  });",
            "title": "_naming_strategies-underscore_mapping"
        },
        {
            "location": "/naming-strategy/composite-naming-strategy/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-hydrator/v2/naming-strategy/composite-naming-strategy/';\n  });",
            "title": "_naming_strategies-composite"
        }
    ]
}